<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="classKDL_1_1Rotation" kind="class" language="C++" prot="public">
    <compoundname>KDL::Rotation</compoundname>
    <includes refid="frames_8hpp" local="no">frames.hpp</includes>
      <sectiondef kind="public-attrib">
      <memberdef kind="variable" id="classKDL_1_1Rotation_1aad4572c3cd7591216d5dc561abbcbdb6" prot="public" static="no" mutable="no">
        <type>double</type>
        <definition>double KDL::Rotation::data[9]</definition>
        <argsstring>[9]</argsstring>
        <name>data</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="306" column="12" bodyfile="src/frames.hpp" bodystart="306" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="friend">
      <memberdef kind="friend" id="classKDL_1_1Rotation_1a9cbb064bc8224853b87dea0dc029fcdb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend bool</type>
        <definition>bool Equal</definition>
        <argsstring>(const Rotation &amp;a, const Rotation &amp;b, double eps)</argsstring>
        <name>Equal</name>
        <param>
          <type>const <ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>double</type>
          <declname>eps</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>do not use operator == because the definition of Equal(.,.) is slightly different. It compares whether the 2 arguments are equal in an eps-interval </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="549" column="18" bodyfile="src/frames.cpp" bodystart="184" bodyend="194"/>
      </memberdef>
      <memberdef kind="friend" id="classKDL_1_1Rotation_1aee3a66b0ddf3b769f015c89b610db0c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend class</type>
        <definition>friend class Frame</definition>
        <argsstring></argsstring>
        <name>Frame</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="556" column="6" bodyfile="src/frames.hpp" bodystart="556" bodyend="-1"/>
      </memberdef>
      <memberdef kind="friend" id="classKDL_1_1Rotation_1a79bfadea66e1395bbfb4e41c91730b8f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend bool</type>
        <definition>bool operator!=</definition>
        <argsstring>(const Rotation &amp;a, const Rotation &amp;b)</argsstring>
        <name>operator!=</name>
        <param>
          <type>const <ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>The literal inequality <ref refid="classKDL_1_1Rotation_1a79bfadea66e1395bbfb4e41c91730b8f" kindref="member">operator!=()</ref> </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="554" column="18"/>
      </memberdef>
      <memberdef kind="friend" id="classKDL_1_1Rotation_1a58290aa6fd60b6103a52cd0dddc695bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend <ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref></type>
        <definition>Rotation operator*</definition>
        <argsstring>(const Rotation &amp;lhs, const Rotation &amp;rhs)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref> &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type>const <ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="330" column="22" bodyfile="src/frames.cpp" bodystart="198" bodyend="213"/>
      </memberdef>
      <memberdef kind="friend" id="classKDL_1_1Rotation_1a6731a7dd43c9617569769ab35aba81a8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend bool</type>
        <definition>bool operator==</definition>
        <argsstring>(const Rotation &amp;a, const Rotation &amp;b)</argsstring>
        <name>operator==</name>
        <param>
          <type>const <ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>The literal equality <ref refid="classKDL_1_1Rotation_1a6731a7dd43c9617569769ab35aba81a8" kindref="member">operator==()</ref>, also identical. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="552" column="18" bodyfile="src/frames.cpp" bodystart="455" bodyend="469"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classKDL_1_1Rotation_1aa1a0ca08f29877875e3c78127266354e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Rotation::DoRotX</definition>
        <argsstring>(double angle)</argsstring>
        <name>DoRotX</name>
        <param>
          <type>double</type>
          <declname>angle</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The DoRot... functions apply a rotation R to *this,such that *this = *this * Rot.. DoRot... functions are only defined when they can be executed more efficiently </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="360" column="17" bodyfile="src/frames.inl" bodystart="556" bodyend="570"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1af6b09f3f066b67e03d17cd2cb3c74b73" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Rotation::DoRotY</definition>
        <argsstring>(double angle)</argsstring>
        <name>DoRotY</name>
        <param>
          <type>double</type>
          <declname>angle</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The DoRot... functions apply a rotation R to *this,such that *this = *this * Rot.. DoRot... functions are only defined when they can be executed more efficiently </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="363" column="17" bodyfile="src/frames.inl" bodystart="572" bodyend="586"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a08fa60d7a860a6f7077ed5adf428ded4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Rotation::DoRotZ</definition>
        <argsstring>(double angle)</argsstring>
        <name>DoRotZ</name>
        <param>
          <type>double</type>
          <declname>angle</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The DoRot... functions apply a rotation R to *this,such that *this = *this * Rot.. DoRot... functions are only defined when they can be executed more efficiently </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="366" column="17" bodyfile="src/frames.inl" bodystart="588" bodyend="602"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1ad826f59ad7a5efa10c549e5577d2f7d9" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void KDL::Rotation::GetEulerZYX</definition>
        <argsstring>(double &amp;Alfa, double &amp;Beta, double &amp;Gamma) const</argsstring>
        <name>GetEulerZYX</name>
        <param>
          <type>double &amp;</type>
          <declname>Alfa</declname>
        </param>
        <param>
          <type>double &amp;</type>
          <declname>Beta</declname>
        </param>
        <param>
          <type>double &amp;</type>
          <declname>Gamma</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>GetEulerZYX gets the euler ZYX parameters of a rotation : First rotate around Z with alfa, then around the new Y with beta, then around new X with gamma.</para>
<para>Range of the results of GetEulerZYX :<itemizedlist>
<listitem><para>-PI &lt;= alfa &lt;= PI</para>
</listitem><listitem><para>-PI &lt;= gamma &lt;= PI</para>
</listitem><listitem><para>-PI/2 &lt;= beta &lt;= PI/2</para>
</listitem></itemizedlist>
</para>
<para>if beta == PI/2 or beta == -PI/2, multiple solutions for gamma and alpha exist. The solution where gamma==0 is chosen.</para>
<para>Invariants:<itemizedlist>
<listitem><para>EulerZYX(alpha,beta,gamma) == EulerZYX(alpha +/- PI, PI-beta, gamma +/- PI)</para>
</listitem><listitem><para>and also (angle + 2*k*PI)</para>
</listitem></itemizedlist>
</para>
<para>Closely related to RPY-convention. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="495" column="17" bodyfile="src/frames.hpp" bodystart="495" bodyend="497"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a01af0b828cb08e3dcca40ece62b77ddf" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void KDL::Rotation::GetEulerZYZ</definition>
        <argsstring>(double &amp;alpha, double &amp;beta, double &amp;gamma) const</argsstring>
        <name>GetEulerZYZ</name>
        <param>
          <type>double &amp;</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>double &amp;</type>
          <declname>beta</declname>
        </param>
        <param>
          <type>double &amp;</type>
          <declname>gamma</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Gives back the EulerZYZ convention description of the rotation matrix : First rotate around Z with alpha, then around the new Y with beta, then around new Z with gamma.</para>
<para>Variables are bound by:<itemizedlist>
<listitem><para>(-PI &lt; alpha &lt;= PI),</para>
</listitem><listitem><para>(0 &lt;= beta &lt;= PI),</para>
</listitem><listitem><para>(-PI &lt; gamma &lt;= PI)</para>
</listitem></itemizedlist>
</para>
<para>if beta==0 or beta==PI, then alpha and gamma are not unique, in this case gamma is chosen to be zero. Invariants:<itemizedlist>
<listitem><para>EulerZYX(alpha,beta,gamma) == EulerZYX(alpha +/- PI, -beta, gamma +/- PI)</para>
</listitem><listitem><para>angle + 2*k*PI </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="417" column="10" bodyfile="src/frames.cpp" bodystart="300" bodyend="316"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1ac8e51b8dce630de273d054710f7458fb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void KDL::Rotation::GetQuaternion</definition>
        <argsstring>(double &amp;x, double &amp;y, double &amp;z, double &amp;w) const</argsstring>
        <name>GetQuaternion</name>
        <param>
          <type>double &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>double &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>double &amp;</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double &amp;</type>
          <declname>w</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the quaternion of this matrix <simplesect kind="post"><para>the norm of (x,y,z,w) is 1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="425" column="10" bodyfile="src/frames.cpp" bodystart="229" bodyend="260"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a0602575044d3b1fdcb4608443f4bff7d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classKDL_1_1Vector" kindref="compound">Vector</ref></type>
        <definition>Vector KDL::Rotation::GetRot</definition>
        <argsstring>() const</argsstring>
        <name>GetRot</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns a vector with the direction of the equiv. axis and its norm is angle </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="379" column="12" bodyfile="src/frames.cpp" bodystart="361" bodyend="369"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a34f8fdc2586b09f59c880bed076cdea5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double KDL::Rotation::GetRotAngle</definition>
        <argsstring>(Vector &amp;axis, double eps=epsilon) const</argsstring>
        <name>GetRotAngle</name>
        <param>
          <type><ref refid="classKDL_1_1Vector" kindref="compound">Vector</ref> &amp;</type>
          <declname>axis</declname>
        </param>
        <param>
          <type>double</type>
          <declname>eps</declname>
          <defval><ref refid="namespaceKDL_1ad69840ad33dc4985798237acfd5fd048" kindref="member">epsilon</ref></defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the rotation angle around the equiv. axis <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>axis</parametername>
</parameternamelist>
<parameterdescription>
<para>the rotation axis is returned in this variable </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>eps</parametername>
</parameternamelist>
<parameterdescription>
<para>: in the case of angle == 0 : rot axis is undefined and chosen to be +/- Z-axis in the case of angle == PI : 2 solutions, positive Z-component of the axis is chosen. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>returns the rotation angle (between [0..PI] )</para>
</simplesect>
Returns the rotation angle around the equiv. axis <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>axis</parametername>
</parameternamelist>
<parameterdescription>
<para>the rotation axis is returned in this variable </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>eps</parametername>
</parameternamelist>
<parameterdescription>
<para>: in the case of angle == 0 : rot axis is undefined and chosen to be the Z-axis in the case of angle == PI : 2 solutions, positive Z-component of the axis is chosen. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>returns the rotation angle (between [0..PI] ) /todo : Check corresponding routines in rframes and rrframes </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="389" column="8" bodyfile="src/frames.cpp" bodystart="383" bodyend="453"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a077721e9049f4ed6c927da6f17c70572" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void KDL::Rotation::GetRPY</definition>
        <argsstring>(double &amp;roll, double &amp;pitch, double &amp;yaw) const</argsstring>
        <name>GetRPY</name>
        <param>
          <type>double &amp;</type>
          <declname>roll</declname>
        </param>
        <param>
          <type>double &amp;</type>
          <declname>pitch</declname>
        </param>
        <param>
          <type>double &amp;</type>
          <declname>yaw</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Gives back a vector in RPY coordinates, variables are bound by<itemizedlist>
<listitem><para>-PI &lt;= roll &lt;= PI</para>
</listitem><listitem><para>-PI &lt;= Yaw &lt;= PI</para>
</listitem><listitem><para>-PI/2 &lt;= PITCH &lt;= PI/2</para>
</listitem></itemizedlist>
</para>
<para>convention :<itemizedlist>
<listitem><para>first rotate around X with roll,</para>
</listitem><listitem><para>then around the old Y with pitch,</para>
</listitem><listitem><para>then around old Z with yaw</para>
</listitem></itemizedlist>
</para>
<para>if pitch == PI/2 or pitch == -PI/2, multiple solutions for gamma and alpha exist. The solution where roll==0 is chosen.</para>
<para>Invariants:<itemizedlist>
<listitem><para>RPY(roll,pitch,yaw) == RPY( roll +/- PI, PI-pitch, yaw +/- PI )</para>
</listitem><listitem><para>angles + 2*k*PI </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="457" column="10" bodyfile="src/frames.cpp" bodystart="274" bodyend="285"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a09a2ee554e814222ef86a8d1ce3267b1" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref></type>
        <definition>Rotation Rotation::Inverse</definition>
        <argsstring>() const</argsstring>
        <name>Inverse</name>
        <briefdescription>
<para>Gives back the inverse rotation matrix of *this. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="336" column="22" bodyfile="src/frames.inl" bodystart="637" bodyend="642"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a1e229277228e2a0c0f3e3faea9dbb79a" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classKDL_1_1Twist" kindref="compound">Twist</ref></type>
        <definition>Twist Rotation::Inverse</definition>
        <argsstring>(const Twist &amp;arg) const</argsstring>
        <name>Inverse</name>
        <param>
          <type>const <ref refid="classKDL_1_1Twist" kindref="compound">Twist</ref> &amp;</type>
          <declname>arg</declname>
        </param>
        <briefdescription>
<para>The same as R.Inverse()*arg but more efficient. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="345" column="19" bodyfile="src/frames.inl" bodystart="180" bodyend="183"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a4e7028b1ed3ded74761155a00bbd7222" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classKDL_1_1Vector" kindref="compound">Vector</ref></type>
        <definition>Vector Rotation::Inverse</definition>
        <argsstring>(const Vector &amp;v) const</argsstring>
        <name>Inverse</name>
        <param>
          <type>const <ref refid="classKDL_1_1Vector" kindref="compound">Vector</ref> &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>The same as R.Inverse()*v but more efficient. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="339" column="20" bodyfile="src/frames.inl" bodystart="644" bodyend="650"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a139ee9c400685a75c4f6fd3acc1ef8ec" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classKDL_1_1Wrench" kindref="compound">Wrench</ref></type>
        <definition>Wrench Rotation::Inverse</definition>
        <argsstring>(const Wrench &amp;arg) const</argsstring>
        <name>Inverse</name>
        <param>
          <type>const <ref refid="classKDL_1_1Wrench" kindref="compound">Wrench</ref> &amp;</type>
          <declname>arg</declname>
        </param>
        <briefdescription>
<para>The same as R.Inverse()*arg but more efficient. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="342" column="20" bodyfile="src/frames.inl" bodystart="175" bodyend="178"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1af1b1952b99b4cb13e36f465f57a55c46" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double &amp;</type>
        <definition>double &amp; Rotation::operator()</definition>
        <argsstring>(int i, int j)</argsstring>
        <name>operator()</name>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type>int</type>
          <declname>j</declname>
        </param>
        <briefdescription>
<para>Access to elements 0..2,0..2, bounds are checked when NDEBUG is not set. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="325" column="20" bodyfile="src/frames.inl" bodystart="488" bodyend="491"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a546f32a66fbd57273f226569ccebc8f8" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double Rotation::operator()</definition>
        <argsstring>(int i, int j) const</argsstring>
        <name>operator()</name>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type>int</type>
          <declname>j</declname>
        </param>
        <briefdescription>
<para>Access to elements 0..2,0..2, bounds are checked when NDEBUG is not set. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="328" column="20" bodyfile="src/frames.inl" bodystart="493" bodyend="496"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1ac9062a29beb152edd602121a7fac6558" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classKDL_1_1Twist" kindref="compound">Twist</ref></type>
        <definition>Twist Rotation::operator*</definition>
        <argsstring>(const Twist &amp;arg) const</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classKDL_1_1Twist" kindref="compound">Twist</ref> &amp;</type>
          <declname>arg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Transformation of the base to which the twist is expressed. Complexity : 18M+12A <simplesect kind="see"><para>Frame*Twist for a transformation that also transforms the velocity reference point. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="503" column="19" bodyfile="src/frames.inl" bodystart="535" bodyend="542"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a130a3edf5e37a9d2b9817093a7c02deb" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classKDL_1_1Vector" kindref="compound">Vector</ref></type>
        <definition>Vector Rotation::operator*</definition>
        <argsstring>(const Vector &amp;v) const</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classKDL_1_1Vector" kindref="compound">Vector</ref> &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Defines a multiplication R*V between a <ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref> R and a <ref refid="classKDL_1_1Vector" kindref="compound">Vector</ref> V. Complexity : 9M+6A </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="322" column="20" bodyfile="src/frames.inl" bodystart="526" bodyend="533"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1adf64f458e61f28f18fb37e5a963ff8aa" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classKDL_1_1Wrench" kindref="compound">Wrench</ref></type>
        <definition>Wrench Rotation::operator*</definition>
        <argsstring>(const Wrench &amp;arg) const</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classKDL_1_1Wrench" kindref="compound">Wrench</ref> &amp;</type>
          <declname>arg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Transformation of the base to which the wrench is expressed. Complexity : 18M+12A <simplesect kind="see"><para>Frame*Wrench for a transformation that also transforms the force reference point. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="509" column="20" bodyfile="src/frames.inl" bodystart="544" bodyend="550"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a111886c82b66d6425d24fb7dbb276e92" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref> &amp;</type>
        <definition>Rotation &amp; Rotation::operator=</definition>
        <argsstring>(const Rotation &amp;arg)</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref> &amp;</type>
          <declname>arg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="318" column="22" bodyfile="src/frames.inl" bodystart="520" bodyend="524"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a2e2696a35bc3bdce4db0d9ed958966d9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>KDL::Rotation::Rotation</definition>
        <argsstring>()</argsstring>
        <name>Rotation</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="308" column="12" bodyfile="src/frames.hpp" bodystart="308" bodyend="310"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a4862d8604c2766dd7393dcf26a18280e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>Rotation::Rotation</definition>
        <argsstring>(const Rotation &amp;arg)</argsstring>
        <name>Rotation</name>
        <param>
          <type>const <ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref> &amp;</type>
          <declname>arg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="316" column="12" bodyfile="src/frames.inl" bodystart="515" bodyend="518"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1acabb1e35f448ce9377c2e3e164f287db" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>Rotation::Rotation</definition>
        <argsstring>(const Vector &amp;x, const Vector &amp;y, const Vector &amp;z)</argsstring>
        <name>Rotation</name>
        <param>
          <type>const <ref refid="classKDL_1_1Vector" kindref="compound">Vector</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classKDL_1_1Vector" kindref="compound">Vector</ref> &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const <ref refid="classKDL_1_1Vector" kindref="compound">Vector</ref> &amp;</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="314" column="12" bodyfile="src/frames.inl" bodystart="508" bodyend="513"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1ad059305eb21561628f4c1a172b30e24c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>Rotation::Rotation</definition>
        <argsstring>(double Xx, double Yx, double Zx, double Xy, double Yy, double Zy, double Xz, double Yz, double Zz)</argsstring>
        <name>Rotation</name>
        <param>
          <type>double</type>
          <declname>Xx</declname>
        </param>
        <param>
          <type>double</type>
          <declname>Yx</declname>
        </param>
        <param>
          <type>double</type>
          <declname>Zx</declname>
        </param>
        <param>
          <type>double</type>
          <declname>Xy</declname>
        </param>
        <param>
          <type>double</type>
          <declname>Yy</declname>
        </param>
        <param>
          <type>double</type>
          <declname>Zy</declname>
        </param>
        <param>
          <type>double</type>
          <declname>Xz</declname>
        </param>
        <param>
          <type>double</type>
          <declname>Yz</declname>
        </param>
        <param>
          <type>double</type>
          <declname>Zz</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="311" column="12" bodyfile="src/frames.inl" bodystart="498" bodyend="505"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1aca0b79dafe708d4623d16c15c239854f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Rotation::SetInverse</definition>
        <argsstring>()</argsstring>
        <name>SetInverse</name>
        <briefdescription>
<para>Sets the value of *this to its inverse. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="333" column="18" bodyfile="src/frames.inl" bodystart="653" bodyend="659"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a281f21f3d632bd84a44fa5caaaebf8e6" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classKDL_1_1Vector" kindref="compound">Vector</ref></type>
        <definition>Vector KDL::Rotation::UnitX</definition>
        <argsstring>() const</argsstring>
        <name>UnitX</name>
        <briefdescription>
<para>Access to the underlying unitvectors of the rotation matrix. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="512" column="20" bodyfile="src/frames.hpp" bodystart="512" bodyend="514"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a8da753f2dac3d1d19c5c4add10b27720" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void KDL::Rotation::UnitX</definition>
        <argsstring>(const Vector &amp;X)</argsstring>
        <name>UnitX</name>
        <param>
          <type>const <ref refid="classKDL_1_1Vector" kindref="compound">Vector</ref> &amp;</type>
          <declname>X</declname>
        </param>
        <briefdescription>
<para>Access to the underlying unitvectors of the rotation matrix. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="517" column="18" bodyfile="src/frames.hpp" bodystart="517" bodyend="521"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a197ba79e104bb6ff43994fceed8f7672" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classKDL_1_1Vector" kindref="compound">Vector</ref></type>
        <definition>Vector KDL::Rotation::UnitY</definition>
        <argsstring>() const</argsstring>
        <name>UnitY</name>
        <briefdescription>
<para>Access to the underlying unitvectors of the rotation matrix. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="524" column="20" bodyfile="src/frames.hpp" bodystart="524" bodyend="526"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1ad84b2efc831af4c9a408a93f702bb087" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void KDL::Rotation::UnitY</definition>
        <argsstring>(const Vector &amp;X)</argsstring>
        <name>UnitY</name>
        <param>
          <type>const <ref refid="classKDL_1_1Vector" kindref="compound">Vector</ref> &amp;</type>
          <declname>X</declname>
        </param>
        <briefdescription>
<para>Access to the underlying unitvectors of the rotation matrix. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="529" column="18" bodyfile="src/frames.hpp" bodystart="529" bodyend="533"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a1fc6a54d079f1ded3414b870b7607a60" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classKDL_1_1Vector" kindref="compound">Vector</ref></type>
        <definition>Vector KDL::Rotation::UnitZ</definition>
        <argsstring>() const</argsstring>
        <name>UnitZ</name>
        <briefdescription>
<para>Access to the underlying unitvectors of the rotation matrix. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="536" column="20" bodyfile="src/frames.hpp" bodystart="536" bodyend="538"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a1ab4feb72d6be853a4dd5ee30427cb3e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void KDL::Rotation::UnitZ</definition>
        <argsstring>(const Vector &amp;X)</argsstring>
        <name>UnitZ</name>
        <param>
          <type>const <ref refid="classKDL_1_1Vector" kindref="compound">Vector</ref> &amp;</type>
          <declname>X</declname>
        </param>
        <briefdescription>
<para>Access to the underlying unitvectors of the rotation matrix. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="541" column="18" bodyfile="src/frames.hpp" bodystart="541" bodyend="545"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classKDL_1_1Rotation_1a39de86d0df854dda05aa9d8516b8e119" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref></type>
        <definition>static Rotation KDL::Rotation::EulerZYX</definition>
        <argsstring>(double Alfa, double Beta, double Gamma)</argsstring>
        <name>EulerZYX</name>
        <param>
          <type>double</type>
          <declname>Alfa</declname>
        </param>
        <param>
          <type>double</type>
          <declname>Beta</declname>
        </param>
        <param>
          <type>double</type>
          <declname>Gamma</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>EulerZYX constructs a <ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref> from the Euler ZYX parameters:<itemizedlist>
<listitem><para>First rotate around Z with alfa,</para>
</listitem><listitem><para>then around the new Y with beta,</para>
</listitem><listitem><para>then around new X with gamma.</para>
</listitem></itemizedlist>
</para>
<para>Closely related to RPY-convention.</para>
<para>Invariants:<itemizedlist>
<listitem><para>EulerZYX(alpha,beta,gamma) == EulerZYX(alpha +/- PI, PI-beta, gamma +/- PI)</para>
</listitem><listitem><para>(angle + 2*k*PI) </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="471" column="28" bodyfile="src/frames.hpp" bodystart="471" bodyend="473"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1ad671cdd779a469544b1d903420d0ded9" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref></type>
        <definition>Rotation KDL::Rotation::EulerZYZ</definition>
        <argsstring>(double Alfa, double Beta, double Gamma)</argsstring>
        <name>EulerZYZ</name>
        <param>
          <type>double</type>
          <declname>Alfa</declname>
        </param>
        <param>
          <type>double</type>
          <declname>Beta</declname>
        </param>
        <param>
          <type>double</type>
          <declname>Gamma</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Gives back a rotation matrix specified with EulerZYZ convention :<itemizedlist>
<listitem><para>First rotate around Z with alfa,</para>
</listitem><listitem><para>then around the new Y with beta,</para>
</listitem><listitem><para>then around new Z with gamma. Invariants:</para>
</listitem></itemizedlist>
</para>
<para>EulerZYX(alpha,beta,gamma) == EulerZYX(alpha +/- PHI, -beta, gamma +/- PI)<itemizedlist>
<listitem><para>(angle + 2*k*PI) </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="400" column="21" bodyfile="src/frames.cpp" bodystart="287" bodyend="297"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a5a5d40d8e6cf179cac35bc378c83017c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref></type>
        <definition>Rotation Rotation::Identity</definition>
        <argsstring>()</argsstring>
        <name>Identity</name>
        <briefdescription>
<para>Gives back an identity rotaton matrix. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="348" column="29" bodyfile="src/frames.inl" bodystart="552" bodyend="554"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a1b1c1e1843d10ac70043d3c3d0358b2f" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref></type>
        <definition>Rotation KDL::Rotation::Quaternion</definition>
        <argsstring>(double x, double y, double z, double w)</argsstring>
        <name>Quaternion</name>
        <param>
          <type>double</type>
          <declname>x</declname>
        </param>
        <param>
          <type>double</type>
          <declname>y</declname>
        </param>
        <param>
          <type>double</type>
          <declname>z</declname>
        </param>
        <param>
          <type>double</type>
          <declname>w</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Gives back a rotation matrix specified with Quaternion convention the norm of (x,y,z,w) should be equal to 1 </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="421" column="21" bodyfile="src/frames.cpp" bodystart="215" bodyend="222"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1ad05c91ff1d5bab2c51b92e349ff9bebb" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref></type>
        <definition>Rotation KDL::Rotation::Rot</definition>
        <argsstring>(const Vector &amp;rotvec, double angle)</argsstring>
        <name>Rot</name>
        <param>
          <type>const <ref refid="classKDL_1_1Vector" kindref="compound">Vector</ref> &amp;</type>
          <declname>rotvec</declname>
        </param>
        <param>
          <type>double</type>
          <declname>angle</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Along an arbitrary axes. It is not necessary to normalize rotvec. returns identity rotation matrix in the case that the norm of rotvec is to small to be used. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="372" column="21" bodyfile="src/frames.cpp" bodystart="318" bodyend="326"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a4e909036d2aad30b631884daa3c15b3b" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref></type>
        <definition>Rotation KDL::Rotation::Rot2</definition>
        <argsstring>(const Vector &amp;rotvec, double angle)</argsstring>
        <name>Rot2</name>
        <param>
          <type>const <ref refid="classKDL_1_1Vector" kindref="compound">Vector</ref> &amp;</type>
          <declname>rotvec</declname>
        </param>
        <param>
          <type>double</type>
          <declname>angle</declname>
        </param>
        <briefdescription>
<para>Along an arbitrary axes. rotvec should be normalized. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="375" column="21" bodyfile="src/frames.cpp" bodystart="328" bodyend="357"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1a60d5c0a5b439a0c2413e94aa45db8cc1" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref></type>
        <definition>Rotation Rotation::RotX</definition>
        <argsstring>(double angle)</argsstring>
        <name>RotX</name>
        <param>
          <type>double</type>
          <declname>angle</declname>
        </param>
        <briefdescription>
<para>The Rot... static functions give the value of the appropriate rotation matrix back. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="353" column="28" bodyfile="src/frames.inl" bodystart="605" bodyend="609"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1ac37c940f7c95f8e2ee84c5f66e7b648e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref></type>
        <definition>Rotation Rotation::RotY</definition>
        <argsstring>(double angle)</argsstring>
        <name>RotY</name>
        <param>
          <type>double</type>
          <declname>angle</declname>
        </param>
        <briefdescription>
<para>The Rot... static functions give the value of the appropriate rotation matrix back. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="355" column="28" bodyfile="src/frames.inl" bodystart="610" bodyend="614"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1aeaa7d2485bb79c3a5be0046eed71c9ce" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref></type>
        <definition>Rotation Rotation::RotZ</definition>
        <argsstring>(double angle)</argsstring>
        <name>RotZ</name>
        <param>
          <type>double</type>
          <declname>angle</declname>
        </param>
        <briefdescription>
<para>The Rot... static functions give the value of the appropriate rotation matrix back. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="357" column="28" bodyfile="src/frames.inl" bodystart="615" bodyend="619"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1Rotation_1afbe17f3c9249078626fba1736aed8d31" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classKDL_1_1Rotation" kindref="compound">Rotation</ref></type>
        <definition>Rotation KDL::Rotation::RPY</definition>
        <argsstring>(double roll, double pitch, double yaw)</argsstring>
        <name>RPY</name>
        <param>
          <type>double</type>
          <declname>roll</declname>
        </param>
        <param>
          <type>double</type>
          <declname>pitch</declname>
        </param>
        <param>
          <type>double</type>
          <declname>yaw</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Gives back a rotation matrix specified with RPY convention: first rotate around X with roll, then around the old Y with pitch, then around old Z with yaw</para>
<para>Invariants:<itemizedlist>
<listitem><para>RPY(roll,pitch,yaw) == RPY( roll +/- PI, PI-pitch, yaw +/- PI )</para>
</listitem><listitem><para>angles + 2*k*PI </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/frames.hpp" line="437" column="21" bodyfile="src/frames.cpp" bodystart="262" bodyend="271"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>represents rotations in 3 dimensional space. </para>
    </briefdescription>
    <detaileddescription>
<para>This class represents a rotation matrix with the following conventions : <verbatim>    Suppose V2 = R*V,                                    (1)
    V is expressed in frame B
    V2 is expressed in frame A
    This matrix R consists of 3 columns [ X,Y,Z ],
    X,Y, and Z contain the axes of frame B, expressed in frame A
    Because of linearity expr(1) is valid.
</verbatim> This class only represents rotational_interpolation, not translation Two interpretations are possible for rotation angles. if you rotate with angle around X frame A to have frame B, then the result of SetRotX is equal to frame B expressed wrt A. In code: <verbatim>     Rotation R;
     F_A_B = R.SetRotX(angle);
</verbatim> Secondly, if you take the following code : <verbatim>     Vector p,p2; Rotation R;
     R.SetRotX(angle);
     p2 = R*p;
</verbatim> then the frame p2 is rotated around X axis with (-angle). Analogue reasonings can be applyd to SetRotY,SetRotZ,SetRot <simplesect kind="par"><title>type</title><para>Concrete implementation </para>
</simplesect>
</para>
    </detaileddescription>
    <location file="src/frames.hpp" line="304" column="1" bodyfile="src/frames.hpp" bodystart="303" bodyend="557"/>
    <listofallmembers>
      <member refid="classKDL_1_1Rotation_1aad4572c3cd7591216d5dc561abbcbdb6" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>data</name></member>
      <member refid="classKDL_1_1Rotation_1aa1a0ca08f29877875e3c78127266354e" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>DoRotX</name></member>
      <member refid="classKDL_1_1Rotation_1af6b09f3f066b67e03d17cd2cb3c74b73" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>DoRotY</name></member>
      <member refid="classKDL_1_1Rotation_1a08fa60d7a860a6f7077ed5adf428ded4" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>DoRotZ</name></member>
      <member refid="classKDL_1_1Rotation_1a9cbb064bc8224853b87dea0dc029fcdb" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>Equal</name></member>
      <member refid="classKDL_1_1Rotation_1a39de86d0df854dda05aa9d8516b8e119" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>EulerZYX</name></member>
      <member refid="classKDL_1_1Rotation_1ad671cdd779a469544b1d903420d0ded9" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>EulerZYZ</name></member>
      <member refid="classKDL_1_1Rotation_1aee3a66b0ddf3b769f015c89b610db0c7" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>Frame</name></member>
      <member refid="classKDL_1_1Rotation_1ad826f59ad7a5efa10c549e5577d2f7d9" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>GetEulerZYX</name></member>
      <member refid="classKDL_1_1Rotation_1a01af0b828cb08e3dcca40ece62b77ddf" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>GetEulerZYZ</name></member>
      <member refid="classKDL_1_1Rotation_1ac8e51b8dce630de273d054710f7458fb" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>GetQuaternion</name></member>
      <member refid="classKDL_1_1Rotation_1a0602575044d3b1fdcb4608443f4bff7d" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>GetRot</name></member>
      <member refid="classKDL_1_1Rotation_1a34f8fdc2586b09f59c880bed076cdea5" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>GetRotAngle</name></member>
      <member refid="classKDL_1_1Rotation_1a077721e9049f4ed6c927da6f17c70572" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>GetRPY</name></member>
      <member refid="classKDL_1_1Rotation_1a5a5d40d8e6cf179cac35bc378c83017c" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>Identity</name></member>
      <member refid="classKDL_1_1Rotation_1a09a2ee554e814222ef86a8d1ce3267b1" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>Inverse</name></member>
      <member refid="classKDL_1_1Rotation_1a4e7028b1ed3ded74761155a00bbd7222" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>Inverse</name></member>
      <member refid="classKDL_1_1Rotation_1a139ee9c400685a75c4f6fd3acc1ef8ec" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>Inverse</name></member>
      <member refid="classKDL_1_1Rotation_1a1e229277228e2a0c0f3e3faea9dbb79a" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>Inverse</name></member>
      <member refid="classKDL_1_1Rotation_1a79bfadea66e1395bbfb4e41c91730b8f" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>operator!=</name></member>
      <member refid="classKDL_1_1Rotation_1af1b1952b99b4cb13e36f465f57a55c46" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>operator()</name></member>
      <member refid="classKDL_1_1Rotation_1a546f32a66fbd57273f226569ccebc8f8" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>operator()</name></member>
      <member refid="classKDL_1_1Rotation_1a130a3edf5e37a9d2b9817093a7c02deb" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>operator*</name></member>
      <member refid="classKDL_1_1Rotation_1a58290aa6fd60b6103a52cd0dddc695bb" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>operator*</name></member>
      <member refid="classKDL_1_1Rotation_1ac9062a29beb152edd602121a7fac6558" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>operator*</name></member>
      <member refid="classKDL_1_1Rotation_1adf64f458e61f28f18fb37e5a963ff8aa" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>operator*</name></member>
      <member refid="classKDL_1_1Rotation_1a111886c82b66d6425d24fb7dbb276e92" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>operator=</name></member>
      <member refid="classKDL_1_1Rotation_1a6731a7dd43c9617569769ab35aba81a8" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>operator==</name></member>
      <member refid="classKDL_1_1Rotation_1a1b1c1e1843d10ac70043d3c3d0358b2f" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>Quaternion</name></member>
      <member refid="classKDL_1_1Rotation_1ad05c91ff1d5bab2c51b92e349ff9bebb" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>Rot</name></member>
      <member refid="classKDL_1_1Rotation_1a4e909036d2aad30b631884daa3c15b3b" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>Rot2</name></member>
      <member refid="classKDL_1_1Rotation_1a2e2696a35bc3bdce4db0d9ed958966d9" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>Rotation</name></member>
      <member refid="classKDL_1_1Rotation_1ad059305eb21561628f4c1a172b30e24c" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>Rotation</name></member>
      <member refid="classKDL_1_1Rotation_1acabb1e35f448ce9377c2e3e164f287db" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>Rotation</name></member>
      <member refid="classKDL_1_1Rotation_1a4862d8604c2766dd7393dcf26a18280e" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>Rotation</name></member>
      <member refid="classKDL_1_1Rotation_1a60d5c0a5b439a0c2413e94aa45db8cc1" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>RotX</name></member>
      <member refid="classKDL_1_1Rotation_1ac37c940f7c95f8e2ee84c5f66e7b648e" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>RotY</name></member>
      <member refid="classKDL_1_1Rotation_1aeaa7d2485bb79c3a5be0046eed71c9ce" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>RotZ</name></member>
      <member refid="classKDL_1_1Rotation_1afbe17f3c9249078626fba1736aed8d31" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>RPY</name></member>
      <member refid="classKDL_1_1Rotation_1aca0b79dafe708d4623d16c15c239854f" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>SetInverse</name></member>
      <member refid="classKDL_1_1Rotation_1a281f21f3d632bd84a44fa5caaaebf8e6" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>UnitX</name></member>
      <member refid="classKDL_1_1Rotation_1a8da753f2dac3d1d19c5c4add10b27720" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>UnitX</name></member>
      <member refid="classKDL_1_1Rotation_1a197ba79e104bb6ff43994fceed8f7672" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>UnitY</name></member>
      <member refid="classKDL_1_1Rotation_1ad84b2efc831af4c9a408a93f702bb087" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>UnitY</name></member>
      <member refid="classKDL_1_1Rotation_1a1fc6a54d079f1ded3414b870b7607a60" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>UnitZ</name></member>
      <member refid="classKDL_1_1Rotation_1a1ab4feb72d6be853a4dd5ee30427cb3e" prot="public" virt="non-virtual"><scope>KDL::Rotation</scope><name>UnitZ</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
