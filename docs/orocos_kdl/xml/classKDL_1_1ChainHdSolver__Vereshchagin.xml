<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="classKDL_1_1ChainHdSolver__Vereshchagin" kind="class" language="C++" prot="public">
    <compoundname>KDL::ChainHdSolver_Vereshchagin</compoundname>
    <basecompoundref refid="classKDL_1_1SolverI" prot="private" virt="non-virtual">KDL::SolverI</basecompoundref>
    <derivedcompoundref refid="classKDL_1_1ChainIdSolver__Vereshchagin" prot="public" virt="non-virtual">KDL::ChainIdSolver_Vereshchagin</derivedcompoundref>
    <includes refid="chainhdsolver__vereshchagin_8hpp" local="no">chainhdsolver_vereshchagin.hpp</includes>
    <innerclass refid="structKDL_1_1ChainHdSolver__Vereshchagin_1_1segment__info" prot="private">KDL::ChainHdSolver_Vereshchagin::segment_info</innerclass>
      <sectiondef kind="private-type">
      <memberdef kind="typedef" id="classKDL_1_1ChainHdSolver__Vereshchagin_1aa371b4dfcc062fac73a6ff606b207eec" prot="private" static="no">
        <type><ref refid="cpp/container/vector" kindref="compound" external="/home/docker/.local/lib/python3.8/site-packages/catkin_tools_document/external/cppreference-doxygen-web.tag.xml">std::vector</ref>&lt; <ref refid="classKDL_1_1Frame" kindref="compound">Frame</ref> &gt;</type>
        <definition>typedef std::vector&lt;Frame&gt; KDL::ChainHdSolver_Vereshchagin::Frames</definition>
        <argsstring></argsstring>
        <name>Frames</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="369" column="25" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="369" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classKDL_1_1ChainHdSolver__Vereshchagin_1a46c31b38dc73e613cabb94a6a8dc6cec" prot="private" static="no">
        <type>Eigen::Matrix&lt; double, 6, 6 &gt;</type>
        <definition>typedef Eigen::Matrix&lt;double, 6, 6 &gt; KDL::ChainHdSolver_Vereshchagin::Matrix6d</definition>
        <argsstring></argsstring>
        <name>Matrix6d</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="371" column="27" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="371" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classKDL_1_1ChainHdSolver__Vereshchagin_1ad7633c8e999db7a29eee10abc215c59e" prot="private" static="no">
        <type>Eigen::Matrix&lt; double, 6, Eigen::Dynamic &gt;</type>
        <definition>typedef Eigen::Matrix&lt;double, 6, Eigen::Dynamic&gt; KDL::ChainHdSolver_Vereshchagin::Matrix6Xd</definition>
        <argsstring></argsstring>
        <name>Matrix6Xd</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="372" column="27" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="372" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classKDL_1_1ChainHdSolver__Vereshchagin_1ae83c1528f9de89ed49de9d6bdcb36b51" prot="private" static="no">
        <type><ref refid="cpp/container/vector" kindref="compound" external="/home/docker/.local/lib/python3.8/site-packages/catkin_tools_document/external/cppreference-doxygen-web.tag.xml">std::vector</ref>&lt; <ref refid="classKDL_1_1Twist" kindref="compound">Twist</ref> &gt;</type>
        <definition>typedef std::vector&lt;Twist&gt; KDL::ChainHdSolver_Vereshchagin::Twists</definition>
        <argsstring></argsstring>
        <name>Twists</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="368" column="25" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="368" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classKDL_1_1ChainHdSolver__Vereshchagin_1a1843697965a4b576c5de1fdb1a0b9e0f" prot="private" static="no">
        <type>Eigen::Matrix&lt; double, 6, 1 &gt;</type>
        <definition>typedef Eigen::Matrix&lt;double, 6, 1 &gt; KDL::ChainHdSolver_Vereshchagin::Vector6d</definition>
        <argsstring></argsstring>
        <name>Vector6d</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="370" column="27" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="370" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classKDL_1_1ChainHdSolver__Vereshchagin_1aba437b36078a7a5bbdfa2f47528b867b" prot="private" static="no" mutable="no">
        <type><ref refid="classKDL_1_1Twist" kindref="compound">Twist</ref></type>
        <definition>Twist KDL::ChainHdSolver_Vereshchagin::acc_root</definition>
        <argsstring></argsstring>
        <name>acc_root</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="470" column="11" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="470" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classKDL_1_1ChainHdSolver__Vereshchagin_1ab02eb0b4e94ebdeab903d27d7d876cf6" prot="private" static="no" mutable="no">
        <type><ref refid="classKDL_1_1Jacobian" kindref="compound">Jacobian</ref></type>
        <definition>Jacobian KDL::ChainHdSolver_Vereshchagin::alfa_N</definition>
        <argsstring></argsstring>
        <name>alfa_N</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="471" column="14" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="471" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classKDL_1_1ChainHdSolver__Vereshchagin_1a863423828321f8b7c4d3ecac68ca8e6b" prot="private" static="no" mutable="no">
        <type><ref refid="classKDL_1_1Jacobian" kindref="compound">Jacobian</ref></type>
        <definition>Jacobian KDL::ChainHdSolver_Vereshchagin::alfa_N2</definition>
        <argsstring></argsstring>
        <name>alfa_N2</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="472" column="14" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="472" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classKDL_1_1ChainHdSolver__Vereshchagin_1ad21a053c569a5e87833dfc54fee2338c" prot="private" static="no" mutable="no">
        <type><ref refid="classKDL_1_1JntArray" kindref="compound">JntArray</ref></type>
        <definition>JntArray KDL::ChainHdSolver_Vereshchagin::beta_N</definition>
        <argsstring></argsstring>
        <name>beta_N</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="476" column="14" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="476" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classKDL_1_1ChainHdSolver__Vereshchagin_1a666f7f03947e8d6af7a6a0f34b187f39" prot="private" static="no" mutable="no">
        <type>const <ref refid="classKDL_1_1Chain" kindref="compound">Chain</ref> &amp;</type>
        <definition>const Chain&amp; KDL::ChainHdSolver_Vereshchagin::chain</definition>
        <argsstring></argsstring>
        <name>chain</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="466" column="17" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="466" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classKDL_1_1ChainHdSolver__Vereshchagin_1a8b7150f6004603becc0426d132db6127" prot="private" static="no" mutable="no">
        <type><ref refid="classKDL_1_1Frame" kindref="compound">Frame</ref></type>
        <definition>Frame KDL::ChainHdSolver_Vereshchagin::F_total</definition>
        <argsstring></argsstring>
        <name>F_total</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="483" column="11" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="483" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classKDL_1_1ChainHdSolver__Vereshchagin_1adb8a0dc3ec545bc9e1dde369908c6bcb" prot="private" static="no" mutable="no">
        <type>Eigen::MatrixXd</type>
        <definition>Eigen::MatrixXd KDL::ChainHdSolver_Vereshchagin::M_0_inverse</definition>
        <argsstring></argsstring>
        <name>M_0_inverse</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="473" column="21" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="473" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classKDL_1_1ChainHdSolver__Vereshchagin_1a978760871e0c047d8af6d3769b1a5017" prot="private" static="no" mutable="no">
        <type>unsigned int</type>
        <definition>unsigned int KDL::ChainHdSolver_Vereshchagin::nc</definition>
        <argsstring></argsstring>
        <name>nc</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="469" column="18" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="469" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classKDL_1_1ChainHdSolver__Vereshchagin_1a43c2223d9ab060bc26bfaf0b0c87e9f2" prot="private" static="no" mutable="no">
        <type>unsigned int</type>
        <definition>unsigned int KDL::ChainHdSolver_Vereshchagin::nj</definition>
        <argsstring></argsstring>
        <name>nj</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="467" column="18" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="467" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classKDL_1_1ChainHdSolver__Vereshchagin_1ac7909354ecaad6b628066de8794b3678" prot="private" static="no" mutable="no">
        <type>unsigned int</type>
        <definition>unsigned int KDL::ChainHdSolver_Vereshchagin::ns</definition>
        <argsstring></argsstring>
        <name>ns</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="468" column="18" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="468" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classKDL_1_1ChainHdSolver__Vereshchagin_1ab4acd2baccbe9851a48a8be542f41769" prot="private" static="no" mutable="no">
        <type>Eigen::VectorXd</type>
        <definition>Eigen::VectorXd KDL::ChainHdSolver_Vereshchagin::nu</definition>
        <argsstring></argsstring>
        <name>nu</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="477" column="21" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="477" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classKDL_1_1ChainHdSolver__Vereshchagin_1ac7ff4cb952f9a644a9e248e864a10c8e" prot="private" static="no" mutable="no">
        <type>Eigen::VectorXd</type>
        <definition>Eigen::VectorXd KDL::ChainHdSolver_Vereshchagin::nu_sum</definition>
        <argsstring></argsstring>
        <name>nu_sum</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="478" column="21" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="478" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classKDL_1_1ChainHdSolver__Vereshchagin_1a4b56988614de9d28d7e2d736b15802ac" prot="private" static="no" mutable="no">
        <type><ref refid="classKDL_1_1Wrench" kindref="compound">Wrench</ref></type>
        <definition>Wrench KDL::ChainHdSolver_Vereshchagin::qdotdot_sum</definition>
        <argsstring></argsstring>
        <name>qdotdot_sum</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="482" column="12" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="482" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classKDL_1_1ChainHdSolver__Vereshchagin_1a0d3bc25675c2118627ee86e1dd47d09b" prot="private" static="no" mutable="no">
        <type><ref refid="cpp/container/vector" kindref="compound" external="/home/docker/.local/lib/python3.8/site-packages/catkin_tools_document/external/cppreference-doxygen-web.tag.xml">std::vector</ref>&lt; <ref refid="structKDL_1_1ChainHdSolver__Vereshchagin_1_1segment__info" kindref="compound">segment_info</ref>, Eigen::aligned_allocator&lt; <ref refid="structKDL_1_1ChainHdSolver__Vereshchagin_1_1segment__info" kindref="compound">segment_info</ref> &gt; &gt;</type>
        <definition>std::vector&lt;segment_info, Eigen::aligned_allocator&lt;segment_info&gt; &gt; KDL::ChainHdSolver_Vereshchagin::results</definition>
        <argsstring></argsstring>
        <name>results</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="530" column="17" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="530" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classKDL_1_1ChainHdSolver__Vereshchagin_1a47b4a7c7b7e12dc6eb44de4921e8588a" prot="private" static="no" mutable="no">
        <type>Eigen::VectorXd</type>
        <definition>Eigen::VectorXd KDL::ChainHdSolver_Vereshchagin::Sm</definition>
        <argsstring></argsstring>
        <name>Sm</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="479" column="21" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="479" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classKDL_1_1ChainHdSolver__Vereshchagin_1a7bdacc6035db9e281786af0a3f415e29" prot="private" static="no" mutable="no">
        <type>Eigen::VectorXd</type>
        <definition>Eigen::VectorXd KDL::ChainHdSolver_Vereshchagin::tmpm</definition>
        <argsstring></argsstring>
        <name>tmpm</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="480" column="21" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="480" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classKDL_1_1ChainHdSolver__Vereshchagin_1a9b951d790bf39fd418208872d390cea4" prot="private" static="no" mutable="no">
        <type>Eigen::VectorXd</type>
        <definition>Eigen::VectorXd KDL::ChainHdSolver_Vereshchagin::total_torques</definition>
        <argsstring></argsstring>
        <name>total_torques</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="481" column="21" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="481" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classKDL_1_1ChainHdSolver__Vereshchagin_1ac4bde5d96159b6287e91ebcd71f6806a" prot="private" static="no" mutable="no">
        <type>Eigen::MatrixXd</type>
        <definition>Eigen::MatrixXd KDL::ChainHdSolver_Vereshchagin::Um</definition>
        <argsstring></argsstring>
        <name>Um</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="474" column="21" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="474" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classKDL_1_1ChainHdSolver__Vereshchagin_1abc5a2daa9a957d31a50da6fa48dd9519" prot="private" static="no" mutable="no">
        <type>Eigen::MatrixXd</type>
        <definition>Eigen::MatrixXd KDL::ChainHdSolver_Vereshchagin::Vm</definition>
        <argsstring></argsstring>
        <name>Vm</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="475" column="21" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="475" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classKDL_1_1ChainHdSolver__Vereshchagin_1a6d48fd72f1e3fa117dba444edb0d5653" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int KDL::ChainHdSolver_Vereshchagin::CartToJnt</definition>
        <argsstring>(const JntArray &amp;q, const JntArray &amp;q_dot, JntArray &amp;q_dotdot, const Jacobian &amp;alfa, const JntArray &amp;beta, const Wrenches &amp;f_ext, const JntArray &amp;ff_torques, JntArray &amp;constraint_torques)</argsstring>
        <name>CartToJnt</name>
        <param>
          <type>const <ref refid="classKDL_1_1JntArray" kindref="compound">JntArray</ref> &amp;</type>
          <declname>q</declname>
        </param>
        <param>
          <type>const <ref refid="classKDL_1_1JntArray" kindref="compound">JntArray</ref> &amp;</type>
          <declname>q_dot</declname>
        </param>
        <param>
          <type><ref refid="classKDL_1_1JntArray" kindref="compound">JntArray</ref> &amp;</type>
          <declname>q_dotdot</declname>
        </param>
        <param>
          <type>const <ref refid="classKDL_1_1Jacobian" kindref="compound">Jacobian</ref> &amp;</type>
          <declname>alfa</declname>
        </param>
        <param>
          <type>const <ref refid="classKDL_1_1JntArray" kindref="compound">JntArray</ref> &amp;</type>
          <declname>beta</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceKDL_1afeffe2d8d9e5e5cfbad0fc90b720c264" kindref="member">Wrenches</ref> &amp;</type>
          <declname>f_ext</declname>
        </param>
        <param>
          <type>const <ref refid="classKDL_1_1JntArray" kindref="compound">JntArray</ref> &amp;</type>
          <declname>ff_torques</declname>
        </param>
        <param>
          <type><ref refid="classKDL_1_1JntArray" kindref="compound">JntArray</ref> &amp;</type>
          <declname>constraint_torques</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This method calculates joint space constraint torques and accelerations. It returns 0 when it succeeds, otherwise -1 or -2 for nonmatching matrix and array sizes. Input parameters: <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>q</parametername>
</parameternamelist>
<parameterdescription>
<para>The current joint positions </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>q_dot</parametername>
</parameternamelist>
<parameterdescription>
<para>The current joint velocities </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>alpha</parametername>
</parameternamelist>
<parameterdescription>
<para>The active constraint directions (unit constraint forces expressed w.r.t. robot&apos;s base frame) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>beta</parametername>
</parameternamelist>
<parameterdescription>
<para>The acceleration energy setpoints (expressed w.r.t. above-defined unit constraint forces) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f_ext</parametername>
</parameternamelist>
<parameterdescription>
<para>The external forces (no gravity, it is given in root acceleration) on the segments </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ff_torques</parametername>
</parameternamelist>
<parameterdescription>
<para>The feed-forward joint space torques</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Output parameters: <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>q_dotdot</parametername>
</parameternamelist>
<parameterdescription>
<para>The resulting joint accelerations </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>constraint_torques</parametername>
</parameternamelist>
<parameterdescription>
<para>The resulting joint constraint torques (what each joint feels due to the constraint forces acting on the end-effector)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>error/success code </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="405" column="9" bodyfile="src/chainhdsolver_vereshchagin.cpp" bodystart="56" bodyend="75"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1ChainHdSolver__Vereshchagin_1a2c3cf54bd2f3f4a41e682b5fb3850345" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>KDL::ChainHdSolver_Vereshchagin::ChainHdSolver_Vereshchagin</definition>
        <argsstring>(const Chain &amp;chain, const Twist &amp;root_acc, const unsigned int nc)</argsstring>
        <name>ChainHdSolver_Vereshchagin</name>
        <param>
          <type>const <ref refid="classKDL_1_1Chain" kindref="compound">Chain</ref> &amp;</type>
          <declname>chain</declname>
        </param>
        <param>
          <type>const <ref refid="classKDL_1_1Twist" kindref="compound">Twist</ref> &amp;</type>
          <declname>root_acc</declname>
        </param>
        <param>
          <type>const unsigned int</type>
          <declname>nc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Constructor for the solver, it will allocate all the necessary memory <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>chain</parametername>
</parameternamelist>
<parameterdescription>
<para>The kinematic chain to calculate the hybrid dynamics for. An internal copy will be made. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>root_acc</parametername>
</parameternamelist>
<parameterdescription>
<para>The acceleration twist of the root segment to use during the calculation (usually contains gravity). Note: This solver takes gravity acceleration with opposite sign comparead to the <ref refid="namespaceKDL" kindref="compound">KDL</ref>&apos;s FD and RNE solvers </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nc</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of constraints imposed on the robot&apos;s end-effector (maximum is 6). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="382" column="5" bodyfile="src/chainhdsolver_vereshchagin.cpp" bodystart="31" bodyend="47"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1ChainHdSolver__Vereshchagin_1a99676a8e2f3690041e5e609d6808b50e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void KDL::ChainHdSolver_Vereshchagin::getContraintForceMagnitude</definition>
        <argsstring>(Eigen::VectorXd &amp;nu_)</argsstring>
        <name>getContraintForceMagnitude</name>
        <param>
          <type>Eigen::VectorXd &amp;</type>
          <declname>nu_</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="417" column="10" bodyfile="src/chainhdsolver_vereshchagin.cpp" bodystart="368" bodyend="372"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1ChainHdSolver__Vereshchagin_1a1ce68d9c9974648498a7e28ab8cebb48" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void KDL::ChainHdSolver_Vereshchagin::getTotalTorque</definition>
        <argsstring>(JntArray &amp;total_tau)</argsstring>
        <name>getTotalTorque</name>
        <param>
          <type><ref refid="classKDL_1_1JntArray" kindref="compound">JntArray</ref> &amp;</type>
          <declname>total_tau</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="414" column="10" bodyfile="src/chainhdsolver_vereshchagin.cpp" bodystart="361" bodyend="365"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1ChainHdSolver__Vereshchagin_1aacddb2d51c10a9f29775306728a621d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void KDL::ChainHdSolver_Vereshchagin::getTransformedLinkAcceleration</definition>
        <argsstring>(Twists &amp;x_dotdot)</argsstring>
        <name>getTransformedLinkAcceleration</name>
        <param>
          <type><ref refid="classKDL_1_1ChainHdSolver__Vereshchagin_1ae83c1528f9de89ed49de9d6bdcb36b51" kindref="member">Twists</ref> &amp;</type>
          <declname>x_dotdot</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="411" column="10" bodyfile="src/chainhdsolver_vereshchagin.cpp" bodystart="352" bodyend="358"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1ChainHdSolver__Vereshchagin_1ac7c90c38d928d5bb337a0098ed7bd743" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void KDL::ChainHdSolver_Vereshchagin::updateInternalDataStructures</definition>
        <argsstring>()</argsstring>
        <name>updateInternalDataStructures</name>
        <reimplements refid="classKDL_1_1SolverI_1a15c4651a994d1c767e14494b37791e79">updateInternalDataStructures</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Update the internal data structures. This is required if the number of segments or number of joints of a chain/tree have changed. This provides a single point of contact for solver memory allocations. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="408" column="18" bodyfile="src/chainhdsolver_vereshchagin.cpp" bodystart="49" bodyend="54"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1ChainHdSolver__Vereshchagin_1a7b9751243f1a9be9dabf65da582f514e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>KDL::ChainHdSolver_Vereshchagin::~ChainHdSolver_Vereshchagin</definition>
        <argsstring>()</argsstring>
        <name>~ChainHdSolver_Vereshchagin</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="384" column="5" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="384" bodyend="386"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classKDL_1_1ChainHdSolver__Vereshchagin_1aa7141a076a659b749078eb96e32bb643" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void KDL::ChainHdSolver_Vereshchagin::constraint_calculation</definition>
        <argsstring>(const JntArray &amp;beta)</argsstring>
        <name>constraint_calculation</name>
        <param>
          <type>const <ref refid="classKDL_1_1JntArray" kindref="compound">JntArray</ref> &amp;</type>
          <declname>beta</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This method calculates constraint force magnitudes. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="458" column="10" bodyfile="src/chainhdsolver_vereshchagin.cpp" bodystart="264" bodyend="297"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1ChainHdSolver__Vereshchagin_1af1ecda96a43e1bba22628559e6476647" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void KDL::ChainHdSolver_Vereshchagin::downwards_sweep</definition>
        <argsstring>(const Jacobian &amp;alfa, const JntArray &amp;ff_torques)</argsstring>
        <name>downwards_sweep</name>
        <param>
          <type>const <ref refid="classKDL_1_1Jacobian" kindref="compound">Jacobian</ref> &amp;</type>
          <declname>alfa</declname>
        </param>
        <param>
          <type>const <ref refid="classKDL_1_1JntArray" kindref="compound">JntArray</ref> &amp;</type>
          <declname>ff_torques</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This method is a force balance sweep. It calculates articulated body inertias and bias forces. Additionally, acceleration energies generated by bias forces and unit forces are calculated here. </para>
        </detaileddescription>
        <inbodydescription>
<para>Additionally adding joint inertia to s.D, see:<itemizedlist>
<listitem><para>equation a) in Vereshchagin89</para>
</listitem><listitem><para>equation 9.28, page 188, Featherstone book 2008</para>
</listitem></itemizedlist>
</para>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="453" column="10" bodyfile="src/chainhdsolver_vereshchagin.cpp" bodystart="138" bodyend="262"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1ChainHdSolver__Vereshchagin_1a1673eaf57a79e6bb3ef1d009bd9d70e4" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void KDL::ChainHdSolver_Vereshchagin::final_upwards_sweep</definition>
        <argsstring>(JntArray &amp;q_dotdot, JntArray &amp;constraint_torques)</argsstring>
        <name>final_upwards_sweep</name>
        <param>
          <type><ref refid="classKDL_1_1JntArray" kindref="compound">JntArray</ref> &amp;</type>
          <declname>q_dotdot</declname>
        </param>
        <param>
          <type><ref refid="classKDL_1_1JntArray" kindref="compound">JntArray</ref> &amp;</type>
          <declname>constraint_torques</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This method puts all acceleration contributions (constraint, bias, nullspace and parent accelerations) together. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="463" column="10" bodyfile="src/chainhdsolver_vereshchagin.cpp" bodystart="299" bodyend="349"/>
      </memberdef>
      <memberdef kind="function" id="classKDL_1_1ChainHdSolver__Vereshchagin_1abac5099e549d272e73525fa10145e79c" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void KDL::ChainHdSolver_Vereshchagin::initial_upwards_sweep</definition>
        <argsstring>(const JntArray &amp;q, const JntArray &amp;q_dot, const JntArray &amp;q_dotdot, const Wrenches &amp;f_ext)</argsstring>
        <name>initial_upwards_sweep</name>
        <param>
          <type>const <ref refid="classKDL_1_1JntArray" kindref="compound">JntArray</ref> &amp;</type>
          <declname>q</declname>
        </param>
        <param>
          <type>const <ref refid="classKDL_1_1JntArray" kindref="compound">JntArray</ref> &amp;</type>
          <declname>q_dot</declname>
        </param>
        <param>
          <type>const <ref refid="classKDL_1_1JntArray" kindref="compound">JntArray</ref> &amp;</type>
          <declname>q_dotdot</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceKDL_1afeffe2d8d9e5e5cfbad0fc90b720c264" kindref="member">Wrenches</ref> &amp;</type>
          <declname>f_ext</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This method calculates all cartesian space poses, twists, bias accelerations. External forces are also taken into account in this outward sweep. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/chainhdsolver_vereshchagin.hpp" line="448" column="10" bodyfile="src/chainhdsolver_vereshchagin.cpp" bodystart="77" bodyend="136"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para><bold>Abstract</bold>: Acceleration constrained hybrid dynamics calculations for a chain, based on Vereshchagin 1989. This class creates an instance of the hybrid dynamics solver. The solver analytically calculates the joint space constraint torques and acceleration in a chain when a constraint force(s) is applied to the chain&apos;s end-effector (task space / cartesian space). In the robotics literature, this algorithm is also known under the following names: Acceleration Constrained Hybrid Dynamics (ACHD) and Popov-Vereshchagin solver. </para>
    </briefdescription>
    <detaileddescription>
<sect2 id="classKDL_1_1ChainHdSolver__Vereshchagin_1autotoc_md6">
<title>INTRODUCTION</title>
<para>In 1970&apos;, researchers [1], [2] have developed a hybrid dynamics algorithm for evaluating robot behavior based on the input specification that is defined by the Cartesian acceleration constraints, feed-forward joint torques and external Cartesian wrenches. The solver is derived from a well-known principle of mechanics - <bold>Gauss&apos; principle of least constraint</bold> [6] and provides an analytical (closed-form) solution to the hybrid dynamics problem with linear-time, <bold>O(n)</bold> complexity [3].</para>
<para>In general, the Gauss&apos; principle states that the true motion (acceleration) of a system/body is defined by the minimum of a quadratic function that is subject to linear geometric motion constraints [7], [6]. The result of this Gauss function represents the <bold>acceleration energy</bold> of a body, which is defined by the product of its mass and the squared distance between its allowed (constrained) acceleration and its free (unconstrained) acceleration [10], [11]. In the case of originally derived Popov-Vereshchagin algorithm [1], geometric motion constraints are Cartesian acceleration constraints imposed on the robot&apos;s end-effector. This domain-specific solver minimizes the acceleration energy by performing computational (outward and inward) sweeps along the robot&apos;s kinematic chain [3]. Furthermore, by computing the minimum of Gauss function, the Popov-Vereshchagin solver resolves the kinematic redundancy of the robot, when a partial motion (task) specification is provided [2]. A necessary condition that enables this type of closed-form algorithm (an analytical solution to the above-described optimization problem) defines that the robot’s kinematic chain does not consist of closed loops, i.e. the robot’s kinematic chain must be constructed in a serial or tree structure [11]. However, it is always possible to cut these loops and introduce explicit constrains.</para>
<para>For evaluating robot dynamics, i.e. resolving its constrained motion, the Popov-Vereshchagin solver is performing three computational sweeps (recursions), along the kinematic chain [3]. More specifically, two sweeps in <bold>outward</bold> and one sweep in <bold>inward</bold> direction. In the case of robot dynamics algorithms, the outward sweep refers to a recursion that is covering a kinematic chain from proximal to distal segments, while the inward sweep is covering a kinematic chain from distal to proximal segments [5]. Additionally, after completing the recursion in the second sweep and before starting the recursion in the last sweep, the solver is computing magnitudes of constraint forces, i.e. the Langrage multiplier (noted as <bold>nu</bold> in the <ref refid="namespaceKDL" kindref="compound">KDL</ref>&apos;s solver implementation and original solver&apos;s publication[2]). More specifically, this operation is performed when the algorithm reaches segment (link) **{0}**, namely the base segment. In this formulation of the solver, the gravity effects are taken into account by setting the base-link&apos;s acceleration equal to gravitational acceleration [3].</para>
<para>For more detailed description of the algorithm and its representation, the reader can refer to [3], [5], [11].</para>
</sect2>
<sect2 id="classKDL_1_1ChainHdSolver__Vereshchagin_1autotoc_md7">
<title>INTERFACES</title>
<sect3 id="classKDL_1_1ChainHdSolver__Vereshchagin_1autotoc_md8">
<title>Solver&apos;s Input</title>
<para>For computing solutions to the constrained hybrid dynamics problem, this original derivation of the Popov-Vereshchagin solver [3] takes into account the following inputs:</para>
<para><itemizedlist>
<listitem><para>Robot&apos;s <bold>model</bold> defined by: kinematic parameters of the chain, segments&apos; mass and rigid-body inertia, and effective inertia of each joint rotor -&gt; <bold>chain</bold> parameter in solver&apos;s constructor</para>
</listitem><listitem><para><bold>Root</bold> acceleration of the robot&apos;s base segment (usually gravitational) -&gt; <bold>root_acc</bold> parameter in solver&apos;s constructor</para>
</listitem><listitem><para>Current joint configuration (angles) -&gt; <bold>q</bold> parameter in the <bold>CartToJnt</bold> function</para>
</listitem><listitem><para>Current joint velocities -&gt; <bold>q_dot</bold> parameter in the <bold>CartToJnt</bold> function</para>
</listitem><listitem><para>Motion drivers:</para>
</listitem><listitem><para>- <bold>Cartesian Acceleration Constraints</bold> imposed on the end-effector segment -&gt; <bold>alpha</bold> and <bold>beta</bold> parameters in the <bold>CartToJnt</bold> function</para>
</listitem><listitem><para>- <bold>Cartesian External <ref refid="classKDL_1_1Wrench" kindref="compound">Wrench</ref></bold> acting on each segment -&gt; <bold>f_ext</bold> parameter in the <bold>CartToJnt</bold> function</para>
</listitem><listitem><para>- <bold>Feed-Forward Torque</bold> acting on each joint -&gt; <bold>ff_torques</bold> parameter in the <bold>CartToJnt</bold> function</para>
</listitem></itemizedlist>
</para>
<para>The following outlines the above-listed task interfaces in more detail.</para>
<sect4 id="classKDL_1_1ChainHdSolver__Vereshchagin_1autotoc_md9">
<title>Cartesian Acceleration Constraints: alpha &amp; beta</title>
<para>This first type of motion driver can be used for specifying <bold>physical</bold> constraints such as contacts with environment [3], or <bold>artificial</bold> (i.e. task-imposed) constraints defined by the operational space task definition for the end-effector (tool-tip) segment. <bold>Note</bold>: the Vereshchagin solver expects that the input Cartesian Acceleration Constraints, i.e. unit constraint forces in alpha parameters, are expressed w.r.t. robot&apos;s base frame. However, the acceleration energy setpoints, i.e. beta parameters, are expressed w.r.t. above-defined unit constraint forces. More specifically, each DOF (element) in beta parameter corresponds to its respective DOF (column) of the unit constraint force matrix (alpha) [11].</para>
<para>To use this interface, a user should define <bold>i)</bold> the active constraint directions via <bold>alpha</bold> parameter, which is a <bold>6 x m</bold> matrix of spatial unit constraint forces, and <bold>ii)</bold> acceleration energy setpoints via <bold>beta</bold>, which is a <bold>m x 1</bold> vector. Here, the number of constraints <bold>m</bold>, or in another words number of spatial unit constraint forces is not required to always be equal to <bold>6</bold>, which means that a human programmer can leave some of the degrees of freedom unspecified [2] for this motion driver, and still produce valid joint control commands [5]. For example, if we want to constrain the motion of the end-effector segment in only one direction, namely linear <bold>x</bold>-direction, we can define the constraint as [3]:</para>
<para><bold>alpha</bold> = <table rows="7" cols="1"><row>
<entry thead="yes"><para></para>
</entry></row>
<row>
<entry thead="no"><para>1  </para>
</entry></row>
<row>
<entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0  </para>
</entry></row>
</table>
</para>
<para><bold>beta</bold> = | 0 |</para>
<para>Note that here, the first three rows of matrix <bold>alpha</bold> represent linear elements and the last three rows represent angular elements, of the spatial unit force defined in Plücker coordinates [4]. By giving zero value to acceleration energy setpoint (<bold>beta</bold>), we are defining that the end-effector is not allowed to have linear acceleration in <bold>x</bold> direction. Or in other words, we are restricting the robot from producing any acceleration energy in that specified direction.</para>
<para>Another example includes the specification of constraints in <bold>5 DOFs</bold>. We can constrain the motion of robot&apos;s end-effector such that it is only allowed to <bold>freely</bold> move in the linear <bold>z</bold>-direction, without performing linear motions in <bold>x</bold> and <bold>y</bold> and angular motions in <bold>x</bold>, <bold>y</bold> and <bold>z</bold> directions:</para>
<para><bold>alpha</bold> = <table rows="7" cols="5"><row>
<entry thead="yes"><para></para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes"><para></para>
</entry></row>
<row>
<entry thead="no"><para>1 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>1 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>1 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>1 </para>
</entry><entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>1  </para>
</entry></row>
</table>
</para>
<para><bold>beta</bold> = <table rows="6" cols="1"><row>
<entry thead="yes"><para></para>
</entry></row>
<row>
<entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0  </para>
</entry></row>
</table>
</para>
<para>For both above-described task examples, the Acceleration Constrained Hybrid Dynamics (ACHD) solver will compute valid control (constraint) joint torques, even though some of the Cartesian DOFs are left unspecified (e.g. in the case of the second example that would be end-effector&apos;s <bold>z</bold>-direction). More specifically: <computeroutput>Underconstrained motion specifications are naturally resolved using Gauss&apos; principle of least constraint</computeroutput> [5]. This means that in those directions in which the robot is not constrained by the task definition, its motions will be controlled by the nature. For instance, in the second example, natural resolution of the robot motion would define that the end-effector &quot;**falls**&quot; in the linear <bold>z</bold> direction due to effects of gravity, with the assumption that gravity forces are acting along $z$-direction.</para>
<para>Moreover, the motion specification in the second example is equivalent to:</para>
<para><bold>alpha</bold> = <table rows="7" cols="6"><row>
<entry thead="yes"><para></para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes"><para></para>
</entry></row>
<row>
<entry thead="no"><para>1 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>1 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>1 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>1 </para>
</entry><entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>1  </para>
</entry></row>
</table>
(note that elements in the third column are all zeros, meaning z-linear constraint is deactivated)</para>
<para><bold>beta</bold> = <table rows="7" cols="1"><row>
<entry thead="yes"><para></para>
</entry></row>
<row>
<entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0  </para>
</entry></row>
</table>
</para>
<para>The last example involves the full specification of the desired end-effector motion (in this case, not necessarily zero accelerations), i.e. specification of constraints in all 6 <bold>DOFs</bold>:</para>
<para><bold>alpha</bold> = <table rows="7" cols="6"><row>
<entry thead="yes"><para></para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes"><para></para>
</entry><entry thead="yes"><para></para>
</entry></row>
<row>
<entry thead="no"><para>1 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>1 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>1 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>1 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>1 </para>
</entry><entry thead="no"><para>0  </para>
</entry></row>
<row>
<entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>0 </para>
</entry><entry thead="no"><para>1  </para>
</entry></row>
</table>
</para>
<para><bold>beta</bold> = <bold>alpha^T * X_dotdot_N</bold></para>
<para>Here, <bold>N</bold> stands for the index of the last robot&apos;s segment, end-effector (tool-tip). The reader should note that we can directly assign values (magnitudes) of the desired (task-defined) spatial acceleration <bold>6 x 1</bold> vector <bold>X_dotdot_N</bold> to the <bold>6 x 1</bold> vector of acceleration energy (<bold>beta</bold>) [3]. Even though physical dimensions (units) of these two vectors are not the same, the property of matrix <bold>alpha</bold> (it contains <bold>unit</bold> vectors), permits that we can assign values of desired accelerations to acceleration energy setpoints, in respective directions. Namely, each column of matrix <bold>alpha</bold> has the value of <bold>1</bold> in the respective direction in which constraint force works, thus it follows that the value of acceleration energy setpoint is the same as the value of Cartesian acceleration, in the respective direction.</para>
</sect4>
<sect4 id="classKDL_1_1ChainHdSolver__Vereshchagin_1autotoc_md10">
<title>External Forces: f_ext</title>
<para>This type of driver can be used for specifying <bold>physical</bold> (but not artificial, i.e. not task-introduced) Cartesian wrenches acting on each of the robot&apos;s segments [11]. Examples for a <bold>physical</bold> force on a segment can be: <bold>i)</bold> a known weight at the robot&apos;s gripper, for instance, a grasped cup or <bold>ii)</bold> a force from a human pushing the robot [5]. Note that the implementation of Vereshchagin solver in <ref refid="namespaceKDL" kindref="compound">KDL</ref> expects the provided <bold>f_ext</bold> is expressed w.r.t. robot&apos;s base frame, which is in contrast to the case of <ref refid="namespaceKDL" kindref="compound">KDL</ref>&apos;s RNE solver.</para>
</sect4>
</sect3>
<sect3 id="classKDL_1_1ChainHdSolver__Vereshchagin_1autotoc_md11">
<title>Feed-Forward Joint Torques: ff_torque</title>
<para>This type of motion driver can be used for specifying <bold>physical</bold> (but not artificial, i.e. not task-introduced) joint torques, for example, spring and/or damper-based torques (e.g. friction effects) in robot&apos;s joints [11].</para>
<para>Additional examples on using these input interfaces can be found in &quot;../tests/solvertest.cpp&quot;:</para>
<para><itemizedlist>
<listitem><para>VereshchaginTest() function - an example on how to use all interfaces of this solver for computing the solution to the Hybrid Dynamics (HD) problem.</para>
</listitem><listitem><para>FdAndVereshchaginSolversConsistencyTest() function - an example on how to only use this solver for computing the solution to the Featherstone&apos;s (i.e. Articulated Body Algorithm (ABA)) version of the Forward Dynamics (FD) problem.</para>
</listitem></itemizedlist>
</para>
</sect3>
<sect3 id="classKDL_1_1ChainHdSolver__Vereshchagin_1autotoc_md12">
<title>Solver&apos;s Output</title>
<para>This recursive dynamics solver is computing several quantities that represent solutions to both, inverse and forward dynamics problems, or in other words solutions to the constrained hybrid dynamics problem. More specifically, the output interface of the original Popov-Vereshchagin algorithm consists of [3], [5]:</para>
<para><itemizedlist>
<listitem><para>Magnitudes of constraint forces that act on the end-effector, denoted by the Lagrange multiplier <bold>nu</bold> in the solver&apos;s implementation and original solver&apos;s publication[2].</para>
</listitem><listitem><para><ref refid="classKDL_1_1Joint" kindref="compound">Joint</ref> constraint torques required for achieving the desired (acceleration-constraints-defined) behavior of the robot: <bold>constraint_torque</bold>. These torques represent control commands that should be sent to robot&apos;s joint drivers.</para>
</listitem><listitem><para>Argument that defines the solution to the originally formulated optimization problem in <bold>Gauss&apos; principle</bold>. In other words, the joint accelerations <bold>q_dotdot</bold> resulting from the total torque acting on each joint (<bold>total_torque</bold>), i.e. from the aforementioned constraint torques and all natural and external forces acting on the system.</para>
</listitem><listitem><para>The resulting and complete spatial accelerations of each segment in the kinematic chain: <bold>X_dotdot</bold></para>
</listitem></itemizedlist>
</para>
<para>Furthermore, if necessary, a complete spatial vector of imposed constraint forces can be computed [3], from the following relation: <bold>alpha * nu</bold>.</para>
<para>The reader should note that this <bold>constraint_torque</bold> is the <bold>necessary</bold> control command that a user is supposed to send to robot&apos;s joints, to achieve the motion that is computed (resolved) by the Popov-Vereshchagin solver. More specifically, here <bold>constraint_torque</bold> represent solution to the <bold>Inverse Dynamics (ID)</bold> problem. Nevertheless, the reason why a user is not supposed to use the <bold>total_torque</bold> values as the control commands for robot&apos;s joints, is the fact that the torque contributions that represent the difference between <bold>total_torque</bold> and <bold>constraint_torque</bold> already exist (act) on robot joints. More specifically, these <bold>additional (residual)</bold> contributions are produced on the joints by the already existing natural forces that act on the system [11].</para>
<para>On the other side, joint accelerations, namely <bold>q_dotdot</bold> provide solution to the <bold>Forward Dynamics (FD)</bold> problem and these quantities can be used for both control (integrate to joint positions/velocities) and simulation purposes [11].</para>
</sect3>
</sect2>
<sect2 id="classKDL_1_1ChainHdSolver__Vereshchagin_1autotoc_md13">
<title>PRACTICAL INSIGHTS/CONSIDERATIONS</title>
<para>The Popov-Vereshchagin hybrid dynamics solver enables a user to achieve many types of operational space tasks [11]. In other words, various controllers can be implemented <bold>around</bold> the aforementioned interfaces of the algorithm. Examples can be controllers for hybrid force/position control, impedance control, etc. However, there are some practical insights about this algorithm that need to taken into account.</para>
<sect3 id="classKDL_1_1ChainHdSolver__Vereshchagin_1autotoc_md14">
<title>Prioritizations between motion drivers (interfaces)</title>
<para>The original derivation of this solver, which is considered in this library, prioritizes Cartesian acceleration constrains (specified for the end-effector segment) over other two motion drivers (Cartesian external wrenches and feedforward joint torques) [11]. In practice, this means the following:</para>
<para><itemizedlist>
<listitem><para>If the external wrenches and/or feedforward joint torques contribute positively (i.e. assist) in producing Cartesian accelerations (specified via acceleration constraint interface), the Vereshchagin solver will take advantage of these forces to compute (acceleration-) energy optimal motions.</para>
</listitem><listitem><para>On the other hand, if the aforementioned external wrenches and/or feedforward joint torques contribute negatively (i.e. interfere) the Cartesian accelerations, the Vereshchagin solver will compensate all of those forces to correctly produce constrained accelerations of the end-effector. More specifically, additional torque commands will be computed under <bold>constrained joint torques</bold> (<bold>ctrl_torques</bold> in this implementation), to overcome those &quot;disturbances&quot;.</para>
</listitem></itemizedlist>
</para>
<para>Nevertheless, the above-described prioritization can be changed (see [3] &amp; [5] for more details) but those features are not implemented in <ref refid="namespaceKDL" kindref="compound">KDL</ref>.</para>
</sect3>
<sect3 id="classKDL_1_1ChainHdSolver__Vereshchagin_1autotoc_md15">
<title>Using the algorithm for solving forward dynamics (FD) problem</title>
<para>The reader should note that the Popov-Vereshchagin solver represents an extension to the well-known forward-dynamics Articulated Body Algorithm (ABA) developed by Featherstone and described in [4] (moreover, Featherstone mentioned Vereshchagin solver in his book [4], page 117). This means that the Popov-Vereshchagin solver can also be purely used as this Articulated Body Algorithm forward-dynamics algorithm. In that case, it is necessary for the user to deactivate all Cartesian acceleration constraints (it is sufficient to set all elements in <bold>alpha</bold> matrix to zero) and proceed using other two interfaces as in the case of standard FD solver. More specifically, use <bold>f_ext</bold> input to define <bold>physical</bold> external wrenches acting on the robot&apos;s body (should be expressed w.r.t. robot&apos;s base frame) and <bold>ff_torque</bold> input to define command torques acting in robot&apos;s joints. The resulting robot&apos;s motion can be taken from <bold>q_dotdot</bold> and <bold>X_dotdot</bold> solver&apos;s outputs.</para>
<para>Nevertheless, the Popov-Vereshchagin solver can also be used for solving more advanced forward dynamics problems, than those solved by ABA [4]. More specifically, if this solver is used in a certain simulation environment for the use-case of simulating robot behaviors, all three interfaces can be exploited for defining a more descriptive robot&apos;s state. Here, a user can exploit the Cartesian acceleration constraint interface to specify different constraints imposed on the end-effector, along with other interfaces, and simulate what would be the robot&apos;s behavior due to these constraints and environmental impacts. Here, the resulting robot&apos;s motion can, as well, be taken from <bold>q_dotdot</bold> and <bold>X_dotdot</bold> solver&apos;s outputs. For example, MuJoCo framework (see MuJoCo&apos;s documentation) also uses Gauss&apos; principle of least constraint to simulate constraint forces in certain situations, however, there, final derivation of this principle in the software is different. However, in the case of this more advanced forward dynamics computations, the user needs to be aware of prioritizations between input interfaces (mentioned in &quot;Prioritizations&quot; section above) and internal policies on handling singularities (mentioned in &quot;Singularities and matrix inversions&quot; section below).</para>
</sect3>
<sect3 id="classKDL_1_1ChainHdSolver__Vereshchagin_1autotoc_md16">
<title>Singularities and matrix inversions</title>
<para>To find the minimal-energy solution to the Inverse Dynamics (ID) problem, i.e. find the Langrage multiplier <bold>nu</bold>, the solver needs to compute the inverse of a so-called &quot;acceleration constraint coupling matrix&quot;[3] in the balance equation before starting the third sweep. However, the robot&apos;s configuration has a direct impact on this matrix and its inversion. Namely, if the robot is in a singular configuration for the task specified via acceleration constraints, this matrix will become rank-deficient. This means that it is not possible to find a feasible solution for that particular end-effector&apos;s DOF that is (or DOFs that are) lost due to the singular configuration. In other words, it is not possible to find <bold>constraint torques</bold> that will satisfy imposed acceleration constraints in that DOF/DOFs. Nevertheless, in this situation, it is still possible to find the (energy-optimal) solution for other &quot;non-singular&quot; DOFs. For that reason, in <ref refid="namespaceKDL" kindref="compound">KDL</ref>&apos;s implementation of the solver, matrix inverse is found by using the SVD technique to construct a pseudo inverse. Additionally, in this implementation, a control policy is introduced via the truncated-SVD method to deactivate, i.e. more specifically <bold>ignore</bold>, acceleration constraints for the DOFs that are lost due to robot&apos;s singular configuration. Of course, this is a choice (control policy), i.e. only one option for solving the singularity problem and producing safe joint commands. It is left for the user to explore other control policies (options) for this particular problem if of course, the user is not satisfied with the current control policy.</para>
</sect3>
<sect3 id="classKDL_1_1ChainHdSolver__Vereshchagin_1autotoc_md17">
<title>Supported robot models</title>
<para><ref refid="namespaceKDL" kindref="compound">KDL</ref>&apos;s current implementation of the Vereshchagin HD solver supports only robot chains that have equal number of joints and segments. Moreover, this implementation can only compute dynamics for <bold>serial</bold> type of chains, i.e. currently, <bold>tree</bold> robot structures are not supported in this solver. Nevertheless, the original solver&apos;s derivation has been extended in [3] to account for multiple motion constraints imposed on a <bold>tree</bold> robot structure. This extension does not only account for acceleration constraints imposed on multiple end-effectors but also for acceleration constraints imposed on more proximal segments. However, the above-mentioned extensions are currently not implemented in this version of <ref refid="namespaceKDL" kindref="compound">KDL</ref>.</para>
</sect3>
</sect2>
<sect2 id="classKDL_1_1ChainHdSolver__Vereshchagin_1autotoc_md18">
<title>REFERENCES</title>
<para>[1] E. P. Popov, A. F. Vereshchagin, and S. L. Zenkevich, &quot;Manipulyatsionnye roboty: Dinamika i algoritmy&quot;, Nauka, Moscow, 1978.</para>
<para>[2] A. F. Vereshchagin, “Modelling and control of motion of manipulation robots”, Soviet Journal of Computer and Systems Sciences, vol. 27, pp. 29–38, 1989.</para>
<para>[3] A. Shakhimardanov, “Composable robot motion stack: Implementing constrained hybrid dynamics using semantic models of kinematic chains”, PhD thesis, KU Leuven, 2015.</para>
<para>[4] R. Featherstone, Rigid body dynamics algorithms. Springer, 2008.</para>
<para>[5] S. Schneider and H. Bruyninckx, “Exploiting linearity in dynamics solvers for the design of composable robotic manipulation architectures”, in IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS), 2019.</para>
<para>[6] H. Bruyninckx and O. Khatib, &quot;Gauss’ principle and the dynamics of redundant and constrained manipulators&quot;, in IEEE International Conference on Robotics and Automation, 2000.</para>
<para>[7] C. F. Gauß, &quot;Über ein neues allgemeines Grundgesetz der Mechanik.&quot;, Journal für die reine und angewandte Mathematik, vol. 4, pp. 232–235, 1829.</para>
<para>[8] A. F. Vereshchagin, “Computer simulation of the dynamics of complicated mechanisms of robot-manipulators”, Engineering Cybernetics, 12(6), pp. 65–70, 1974.</para>
<para>[9] E. P. Popov, &quot;Control of robots-manipulators&quot;, Engineering Cybernetics, 1974.</para>
<para>[10] E. Ramm, “Principles of least action and of least constraint”, GAMM-Mitteilungen, vol. 34, pp. 164–182, 2011.</para>
<para>[11] D. Vukcevic, &quot;Lazy Robot Control by Relaxation of Motion and Force Constraints.&quot; Technical Report/Hochschule Bonn-Rhein-Sieg University of Applied Sciences, Department of Computer Science, 2020. </para>
</sect2>
    </detaileddescription>
    <inheritancegraph>
      <node id="2">
        <label>KDL::SolverI</label>
        <link refid="classKDL_1_1SolverI"/>
      </node>
      <node id="3">
        <label>KDL::ChainIdSolver_Vereshchagin</label>
        <link refid="classKDL_1_1ChainIdSolver__Vereshchagin"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>KDL::ChainHdSolver_Vereshchagin</label>
        <link refid="classKDL_1_1ChainHdSolver__Vereshchagin"/>
        <childnode refid="2" relation="private-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="10">
        <label>KDL::Rotation</label>
        <link refid="classKDL_1_1Rotation"/>
      </node>
      <node id="8">
        <label>std::vector&lt; KDL::Segment &gt;</label>
        <link refid="cpp/container/vector" external="/home/docker/.local/lib/python3.8/site-packages/catkin_tools_document/external/cppreference-doxygen-web.tag.xml"/>
      </node>
      <node id="11">
        <label>std::vector&lt; KDL::ChainHdSolver_Vereshchagin::segment_info, Eigen::aligned_allocator&lt; KDL::ChainHdSolver_Vereshchagin::segment_info &gt; &gt;</label>
        <link refid="cpp/container/vector" external="/home/docker/.local/lib/python3.8/site-packages/catkin_tools_document/external/cppreference-doxygen-web.tag.xml"/>
      </node>
      <node id="3">
        <label>KDL::Twist</label>
        <link refid="classKDL_1_1Twist"/>
        <childnode refid="4" relation="usage">
          <edgelabel>rot</edgelabel>
          <edgelabel>vel</edgelabel>
        </childnode>
      </node>
      <node id="2">
        <label>KDL::SolverI</label>
        <link refid="classKDL_1_1SolverI"/>
      </node>
      <node id="6">
        <label>KDL::Wrench</label>
        <link refid="classKDL_1_1Wrench"/>
        <childnode refid="4" relation="usage">
          <edgelabel>force</edgelabel>
          <edgelabel>torque</edgelabel>
        </childnode>
      </node>
      <node id="12">
        <label>KDL::JntArray</label>
        <link refid="classKDL_1_1JntArray"/>
      </node>
      <node id="9">
        <label>KDL::Frame</label>
        <link refid="classKDL_1_1Frame"/>
        <childnode refid="4" relation="usage">
          <edgelabel>p</edgelabel>
        </childnode>
        <childnode refid="10" relation="usage">
          <edgelabel>M</edgelabel>
        </childnode>
      </node>
      <node id="7">
        <label>KDL::Chain</label>
        <link refid="classKDL_1_1Chain"/>
        <childnode refid="8" relation="usage">
          <edgelabel>segments</edgelabel>
        </childnode>
      </node>
      <node id="5">
        <label>KDL::Jacobian</label>
        <link refid="classKDL_1_1Jacobian"/>
      </node>
      <node id="1">
        <label>KDL::ChainHdSolver_Vereshchagin</label>
        <link refid="classKDL_1_1ChainHdSolver__Vereshchagin"/>
        <childnode refid="2" relation="private-inheritance">
        </childnode>
        <childnode refid="3" relation="usage">
          <edgelabel>acc_root</edgelabel>
        </childnode>
        <childnode refid="5" relation="usage">
          <edgelabel>alfa_N</edgelabel>
          <edgelabel>alfa_N2</edgelabel>
        </childnode>
        <childnode refid="6" relation="usage">
          <edgelabel>qdotdot_sum</edgelabel>
        </childnode>
        <childnode refid="7" relation="usage">
          <edgelabel>chain</edgelabel>
        </childnode>
        <childnode refid="9" relation="usage">
          <edgelabel>F_total</edgelabel>
        </childnode>
        <childnode refid="11" relation="usage">
          <edgelabel>results</edgelabel>
        </childnode>
        <childnode refid="12" relation="usage">
          <edgelabel>beta_N</edgelabel>
        </childnode>
      </node>
      <node id="4">
        <label>KDL::Vector</label>
        <link refid="classKDL_1_1Vector"/>
      </node>
    </collaborationgraph>
    <location file="src/chainhdsolver_vereshchagin.hpp" line="367" column="1" bodyfile="src/chainhdsolver_vereshchagin.hpp" bodystart="366" bodyend="532"/>
    <listofallmembers>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1aba437b36078a7a5bbdfa2f47528b867b" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>acc_root</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1ab02eb0b4e94ebdeab903d27d7d876cf6" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>alfa_N</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1a863423828321f8b7c4d3ecac68ca8e6b" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>alfa_N2</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1ad21a053c569a5e87833dfc54fee2338c" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>beta_N</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1a6d48fd72f1e3fa117dba444edb0d5653" prot="public" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>CartToJnt</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1a666f7f03947e8d6af7a6a0f34b187f39" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>chain</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1a2c3cf54bd2f3f4a41e682b5fb3850345" prot="public" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>ChainHdSolver_Vereshchagin</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1aa7141a076a659b749078eb96e32bb643" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>constraint_calculation</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1af1ecda96a43e1bba22628559e6476647" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>downwards_sweep</name></member>
      <member refid="classKDL_1_1SolverI_1a73d6b62495bbc2626a85004002b2c148a037090bae35fcc0264c70287d3b926d6" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>E_DEGRADED</name></member>
      <member refid="classKDL_1_1SolverI_1a73d6b62495bbc2626a85004002b2c148a17178be368599dd456b54c2d37c4fb50" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>E_MAX_ITERATIONS_EXCEEDED</name></member>
      <member refid="classKDL_1_1SolverI_1a73d6b62495bbc2626a85004002b2c148aa19df6d3f1007614f98aadbaea84d89f" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>E_NO_CONVERGE</name></member>
      <member refid="classKDL_1_1SolverI_1a73d6b62495bbc2626a85004002b2c148a95f2e049884a3a08fc4f839e4cbf6191" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>E_NOERROR</name></member>
      <member refid="classKDL_1_1SolverI_1a73d6b62495bbc2626a85004002b2c148a749aec827a10228473b653f18bc20197" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>E_NOT_IMPLEMENTED</name></member>
      <member refid="classKDL_1_1SolverI_1a73d6b62495bbc2626a85004002b2c148a1803914d79d602cbc5ffced121c5278c" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>E_NOT_UP_TO_DATE</name></member>
      <member refid="classKDL_1_1SolverI_1a73d6b62495bbc2626a85004002b2c148af7440fec45c6d1657a89d344ff5b6583" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>E_OUT_OF_RANGE</name></member>
      <member refid="classKDL_1_1SolverI_1a73d6b62495bbc2626a85004002b2c148a713b62c139a0caee351f94aa7598e56a" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>E_SIZE_MISMATCH</name></member>
      <member refid="classKDL_1_1SolverI_1a73d6b62495bbc2626a85004002b2c148ac70eed0a4997fd525b00e5eddeb39ba5" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>E_SVD_FAILED</name></member>
      <member refid="classKDL_1_1SolverI_1a73d6b62495bbc2626a85004002b2c148a4ad4b1f9f4f4c7dd43898c06ecc73c06" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>E_UNDEFINED</name></member>
      <member refid="classKDL_1_1SolverI_1a62d29639f6396a0660ce7e3958d14718" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>error</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1a8b7150f6004603becc0426d132db6127" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>F_total</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1a1673eaf57a79e6bb3ef1d009bd9d70e4" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>final_upwards_sweep</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1aa371b4dfcc062fac73a6ff606b207eec" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>Frames</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1a99676a8e2f3690041e5e609d6808b50e" prot="public" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>getContraintForceMagnitude</name></member>
      <member refid="classKDL_1_1SolverI_1a0473a25058060878b90ace7324ae1d47" prot="private" virt="virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>getError</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1a1ce68d9c9974648498a7e28ab8cebb48" prot="public" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>getTotalTorque</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1aacddb2d51c10a9f29775306728a621d6" prot="public" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>getTransformedLinkAcceleration</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1abac5099e549d272e73525fa10145e79c" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>initial_upwards_sweep</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1adb8a0dc3ec545bc9e1dde369908c6bcb" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>M_0_inverse</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1a46c31b38dc73e613cabb94a6a8dc6cec" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>Matrix6d</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1ad7633c8e999db7a29eee10abc215c59e" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>Matrix6Xd</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1a978760871e0c047d8af6d3769b1a5017" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>nc</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1a43c2223d9ab060bc26bfaf0b0c87e9f2" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>nj</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1ac7909354ecaad6b628066de8794b3678" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>ns</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1ab4acd2baccbe9851a48a8be542f41769" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>nu</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1ac7ff4cb952f9a644a9e248e864a10c8e" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>nu_sum</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1a4b56988614de9d28d7e2d736b15802ac" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>qdotdot_sum</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1a0d3bc25675c2118627ee86e1dd47d09b" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>results</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1a47b4a7c7b7e12dc6eb44de4921e8588a" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>Sm</name></member>
      <member refid="classKDL_1_1SolverI_1a2fd94680969bab93b792dabfdcfc9a80" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>SolverI</name></member>
      <member refid="classKDL_1_1SolverI_1a5f9c4f020d4d609d8d10a7a949e8195c" prot="private" virt="virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>strError</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1a7bdacc6035db9e281786af0a3f415e29" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>tmpm</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1a9b951d790bf39fd418208872d390cea4" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>total_torques</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1ae83c1528f9de89ed49de9d6bdcb36b51" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>Twists</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1ac4bde5d96159b6287e91ebcd71f6806a" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>Um</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1ac7c90c38d928d5bb337a0098ed7bd743" prot="public" virt="virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>updateInternalDataStructures</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1a1843697965a4b576c5de1fdb1a0b9e0f" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>Vector6d</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1abc5a2daa9a957d31a50da6fa48dd9519" prot="private" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>Vm</name></member>
      <member refid="classKDL_1_1ChainHdSolver__Vereshchagin_1a7b9751243f1a9be9dabf65da582f514e" prot="public" virt="non-virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>~ChainHdSolver_Vereshchagin</name></member>
      <member refid="classKDL_1_1SolverI_1ab70782f0d3632c22fcd430ef719d0f2f" prot="private" virt="virtual"><scope>KDL::ChainHdSolver_Vereshchagin</scope><name>~SolverI</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
