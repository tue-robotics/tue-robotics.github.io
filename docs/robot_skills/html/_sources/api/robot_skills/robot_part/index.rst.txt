robot_skills.robot_part
=======================

.. py:module:: robot_skills.robot_part


Attributes
----------

.. autoapisummary::

   robot_skills.robot_part.SIM_MODE


Classes
-------

.. autoapisummary::

   robot_skills.robot_part.RobotPart


Module Contents
---------------

.. py:data:: SIM_MODE

.. py:class:: RobotPart(robot_name, tf_buffer)

   Bases: :py:obj:`object`


   Base class for robot parts

   Constructor

   :param robot_name: string with robot name
   :param tf_buffer: tf buffer object


   .. py:attribute:: robot_name


   .. py:attribute:: tf_buffer
      :type:  tf2_ros.Buffer


   .. py:attribute:: parts


   .. py:attribute:: functionalities
      :value: []



   .. py:attribute:: __ros_connections


   .. py:attribute:: __diagnostics_name
      :value: ''



   .. py:attribute:: _operational
      :value: True



   .. py:method:: close()

      Close the robot part



   .. py:method:: add_part(partname, part)

      Add a component part to the robot part. This is added to the parts dict and set as an attribute

      :param partname: name of the bodypart
      :param part: bodypart object



   .. py:method:: load_param(param_name, default=None)

      Loads a parameter from the parameter server, namespaced by robot name

      :param param_name: parameter name
      :param default: default value for when parameter unavailable
      :return: loaded parameters



   .. py:method:: wait_for_connections(timeout, log_failing_connections=True)

      Waits for the connections until they are connected

      :param timeout: timeout in seconds
      :param log_failing_connections: (bool) whether to log errors if not connected. This is useful when checking
          multiple robot parts in a loop
      :return: bool indicating whether all connections are connected



   .. py:method:: create_simple_action_client(name, action_type)

      Creates a simple actionlib client and waits for the action server

      :param name: string with the name of the action in the correct namespace
      :param action_type: action type of this action
      :return: the action client



   .. py:method:: create_service_client(name, srv_type)

      Creates a service client and waits for the server
      :param name: string with the name of the service in the correct namespace
      :param srv_type: service type
      :return: the service client



   .. py:method:: create_subscriber(name, *args, **kwargs)

      Creates a Subscriber and add to the connections to check

      :param name: string with the name topic to subscribe
      :param args: other args passed to rospy.Subscriber
      :param kwargs: other keyword args passed to rospy.Subscriber
      :return: the Subscriber



   .. py:method:: _add_connection(name, connection)

      Adds a connection to the internal dict with connections that is used when initializing the robot object.

      :param name: name of the connection
      :param connection: connection to add. This might be a ServiceProxy, ActionClient or Subscriber



   .. py:property:: operational

      Check whether this bodypart's hardware is operational
      If the associated hardware is not yet up, has an error etc, the bodypart is not operational. Note: in
      in simulation: operational is always true

      :rtype: bool True is part is ready to do work, False otherwise


   .. py:method:: subscribe_hardware_status(name)

      Start to check if the bodypart is operational. To do so, subscribe to the hardware status/diagnostics

      :param name: check on the level of the diagnostic_msgs/DiagnosticStatus with this name



   .. py:method:: unsubscribe_hardware_status()

      When process_hardware_status sees that self.__diagnostics_name evaluates to False,
          it will not process the diagnostics and ignore them



   .. py:method:: process_hardware_status(diagnostic_dict)

      hardware_status callback to determine if the bodypart is operational

      :param diagnostic_dict: dictionary[str, diagnostic_msgs.msg.DiagnosticStatus]
      :return: no return



   .. py:method:: reset()

      Reset body part and all its components, this function should not be overwritten.

      :return: Succes
      :rtype: bool



   .. py:method:: selfreset()

      Reset of the body part itself. This function may be overwritten.
      Returns: bool



