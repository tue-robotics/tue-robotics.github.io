robot_smach_states.util.designators.checks
==========================================

.. py:module:: robot_smach_states.util.designators.checks


Attributes
----------

.. autoapisummary::

   robot_smach_states.util.designators.checks.__author__


Functions
---------

.. autoapisummary::

   robot_smach_states.util.designators.checks.check_resolve_type
   robot_smach_states.util.designators.checks.check_type
   robot_smach_states.util.designators.checks.is_writeable


Module Contents
---------------

.. py:data:: __author__
   :value: 'loy'


.. py:function:: check_resolve_type(designator, *allowed_types)

   Check if the resolve type of a designator is one of the allowed types. If the resolve type is a list, the internal
   type is also checked.

       Incorrect: []; [str, int]
       Correct: [str]; [str], [int]

   This check allows for type checking on construction of a statemachine, so runtime error can be prevented.

   :param designator: Designator to check the resolve type of. In case of a list resolve type, one type in the list
       needs to be defined.
   :param allowed_types: Allowed resolve type of the designator. Allowed list types, also need to have an internal type
       defined.

   >>> from robot_smach_states.util.designators.core import Designator
   >>> d1 = Designator("a", resolve_type=str, name='d1')
   >>> check_resolve_type(d1, str)
   >>> d2 = Designator("a", resolve_type=str, name='d2')
   >>> check_resolve_type(d2, int, str)

   >>> d3 = Designator("a", resolve_type=str, name='d3')
   >>> #The resolve_type is actually str but we check for int, thus get an exception
   >>> check_resolve_type(d3, int)  # doctest: +IGNORE_EXCEPTION_DETAIL
   Traceback (most recent call last):
     ...
   TypeError: ...

   >>> d4 = Designator("a", resolve_type=str, name='d4')
   >>> #The resolve_type is actually str but we check for int, thus get an exception
   >>> check_resolve_type(d4, float, int)  # doctest: +IGNORE_EXCEPTION_DETAIL
   Traceback (most recent call last):
     ...
   TypeError: ...

   >>> d5 = Designator(["a", "b", "c"], resolve_type=[str], name='d5')

   >>> d6 = Designator(["a", "b", "c"], resolve_type=[str], name='d6')
   >>> #The resolve_type is actually [str] but we check for [int], thus get an exception
   >>> check_resolve_type(d6, [int])  # doctest: +IGNORE_EXCEPTION_DETAIL
   Traceback (most recent call last):
     ...
   TypeError: ...

   >>> d7 = Designator("a", resolve_type=str, name='d7')
   >>> d8 = Designator(["a"], resolve_type=[str], name='d8')
   >>> check_resolve_type(d7, str, [str])
   >>> check_resolve_type(d8, str, [str])
   >>> check_resolve_type(d7, [str], str)
   >>> check_resolve_type(d8, [str], str)


.. py:function:: check_type(designator_or_value, *allowed_types)

   Check if the resolve type of a designator or a variable is one of the allowed types. If the type is a list, the internal
   type is also checked.
   Incorrect: []; [str, int]
   Correct: [str]; [str], [int]
   This check allows for type checking on construction of a statemachine, so runtime error can be prevented.

   :param designator_or_value: Designator or variable to check the type of.
   :param allowed_types: Allowed type of the designator or variable.

   >>> from robot_smach_states.util.designators.core import Designator
   >>> d = Designator("a", resolve_type=str)
   >>> check_type(d, str)
   >>> c = "a"
   >>> check_type(c, int, str)

   >>> c2 = "string"
   >>> #The type is str but we check for int, thus get an exception
   >>> check_type(c2, int)  # doctest: +IGNORE_EXCEPTION_DETAIL
   Traceback (most recent call last):
     ...
   TypeError: ...

   >>> c3 = Designator(["a"], resolve_type=[str], name='c3')
   >>> check_type(c3, [str])
   >>> check_type(c3, str, [str])
   >>> check_type(c3, [str], str)
   >>> c4 = ["a"]
   >>> check_type(c4, [str])
   >>> check_type(c4, str, [str])
   >>> check_type(c4, [str], str)
   >>> check_type(c4, [int])  # doctest: +IGNORE_EXCEPTION_DETAIL
   Traceback (most recent call last):
     ...
   TypeError: ...
   >>> check_type(c4, [str, int])  # doctest: +IGNORE_EXCEPTION_DETAIL
   Traceback (most recent call last):
     ...
   AssertionError: ...


.. py:function:: is_writeable(variable_writer)

