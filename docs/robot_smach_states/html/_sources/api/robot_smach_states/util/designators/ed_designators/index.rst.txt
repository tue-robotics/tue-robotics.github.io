robot_smach_states.util.designators.ed_designators
==================================================

.. py:module:: robot_smach_states.util.designators.ed_designators


Attributes
----------

.. autoapisummary::

   robot_smach_states.util.designators.ed_designators.__author__


Classes
-------

.. autoapisummary::

   robot_smach_states.util.designators.ed_designators.EdEntityCollectionDesignator
   robot_smach_states.util.designators.ed_designators.EdEntityDesignator
   robot_smach_states.util.designators.ed_designators.EntityByIdDesignator
   robot_smach_states.util.designators.ed_designators.ReasonedEntityDesignator
   robot_smach_states.util.designators.ed_designators.LockToId


Module Contents
---------------

.. py:data:: __author__
   :value: 'loy'


.. py:class:: EdEntityCollectionDesignator(robot, etype='', center_point=None, radius=float('inf'), uuid='', criteriafuncs=None, etype_designator=None, center_point_designator=None, uuid_designator=None, name=None)

   Bases: :py:obj:`robot_smach_states.util.designators.core.Designator`


   Resolves to a collection of Ed entities

   >>> from robot_skills.mockbot import Mockbot
   >>> with redirect_stdout(None): robot = Mockbot()
   >>> entities = EdEntityCollectionDesignator(robot)
   >>> check_resolve_type(entities, [Entity]) #This is more a test for check_resolve_type to be honest :-/

   Designates a collection of entities of some type, within a radius of some center_point, with some id,
   that match some given criteria functions.
   @param robot the robot to use for Ed queries
   @param etype the type of the entity to resolve to (default: any type)
   @param center_point combined with radius: a sphere to search an entity in
   @param radius combined with center_point: a sphere to search an entity in
   @param uuid the ID of the object to get info about
   @param etype_designator same as type but dynamically resolved trhough a designator. Mutually exclusive with type
   @param center_point_designator same as center_point but dynamically resolved through a designator.
           Mutually exclusive with center_point
   @param uuid_designator same as id but dynamically resolved through a designator. Mutually exclusive with id


   .. py:attribute:: ed


   .. py:attribute:: etype
      :value: ''



   .. py:attribute:: center_point
      :value: None



   .. py:attribute:: radius


   .. py:attribute:: uuid
      :value: ''



   .. py:attribute:: criteriafuncs
      :value: []



   .. py:attribute:: etype_designator
      :value: None



   .. py:attribute:: center_point_designator
      :value: None



   .. py:attribute:: uuid_designator
      :value: None



   .. py:method:: _resolve()


.. py:class:: EdEntityDesignator(robot, etype='', center_point=None, radius=float('inf'), uuid='', criteriafuncs=None, weight_function=None, etype_designator=None, center_point_designator=None, uuid_designator=None, name=None)

   Bases: :py:obj:`robot_smach_states.util.designators.core.Designator`


   Resolves to an entity from an Ed query

   Designates an entity of some type, within a radius of some center_point, with some id,
   that match some given criteria functions.
   @param robot the robot to use for Ed queries
   @param etype the type of the entity to resolve to (default: any type)
   @param center_point combined with radius: a sphere to search an entity in
   @param radius combined with center_point: a sphere to search an entity in
   @param uuid the ID of the object to get info about
   @param criteriafuncs a list of functions that take an entity and return a bool (True if criterium met)
   @param weight_function returns a weight for each entity, the one with the lowest weight will be selected
   (could be a distance calculation)
   @param etype_designator same as type but dynamically resolved trhough a designator. Mutually exclusive with type
   @param center_point_designator same as center_point but dynamically resolved trhough a designator.
   Mutually exclusive with center_point
   @param uuid_designator same as id but dynamically resolved through a designator. Mutually exclusive with id


   .. py:attribute:: robot


   .. py:attribute:: ed


   .. py:attribute:: etype
      :value: ''



   .. py:attribute:: center_point
      :value: None



   .. py:attribute:: radius


   .. py:attribute:: uuid
      :value: ''



   .. py:attribute:: criteriafuncs
      :value: []



   .. py:attribute:: weight_function


   .. py:attribute:: etype_designator
      :value: None



   .. py:attribute:: center_point_designator
      :value: None



   .. py:attribute:: uuid_designator
      :value: None



   .. py:method:: lockable()


   .. py:method:: _resolve()


.. py:class:: EntityByIdDesignator(robot, uuid, name=None)

   Bases: :py:obj:`robot_smach_states.util.designators.core.Designator`


   
   Designate an entity by its ID. Resolves to the entity with that ID

   :param robot: Robot who's worldmodel to use
   :param uuid: ID of the entity. If no such ID, resolves to None
   :param name: Name of the designator for introspection purposes


   .. py:attribute:: ed


   .. py:attribute:: uuid


   .. py:method:: _resolve()


   .. py:method:: __repr__()


.. py:class:: ReasonedEntityDesignator(robot, query, name=None)

   Bases: :py:obj:`robot_smach_states.util.designators.core.Designator`


   
   Designate an entity by its ID. Resolves to the entity with that ID

   :param robot: Robot who's worldmodel and reasoner to use. Robot must have a reasoner
   :param query: query to the reasoner. The first answer is cast to string and used as ID
   :param name: Name of the designator for introspection purposes


   .. py:attribute:: robot


   .. py:attribute:: querystring


   .. py:attribute:: _locker
      :value: None



   .. py:method:: _resolve()


   .. py:method:: lockable()


.. py:class:: LockToId(robot, to_be_locked, name=None)

   Bases: :py:obj:`robot_smach_states.util.designators.core.Designator`


   An Entity...Designator's resolve() method may return a different Entity everytime.
   For some cases, this may be unwanted because a process has to be done with the same Entity for tha action to be
   consistent.
   In that case, a designator resolving to a different object every time is not usable.
   A LockToId will resolve to the same Entity after a call to .lock() and
   will only resolve to a different Entity after an unlock() call.
   This is done by remembering the Entity's ID

   Constructor

   :param robot: robot object
   :param to_be_locked: designator to be locked
   :param name: (optional) might come in handy for debugging


   .. py:attribute:: robot


   .. py:attribute:: to_be_locked


   .. py:attribute:: _locked_to_uuid
      :value: None



   .. py:attribute:: _locked
      :value: False



   .. py:method:: lock()


   .. py:method:: unlock()


   .. py:method:: _resolve()


   .. py:method:: __repr__()


