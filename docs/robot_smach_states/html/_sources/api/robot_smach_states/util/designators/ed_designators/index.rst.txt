robot_smach_states.util.designators.ed_designators
==================================================

.. py:module:: robot_smach_states.util.designators.ed_designators


Attributes
----------

.. autoapisummary::

   robot_smach_states.util.designators.ed_designators.__author__


Classes
-------

.. autoapisummary::

   robot_smach_states.util.designators.ed_designators.EdEntityCollectionDesignator
   robot_smach_states.util.designators.ed_designators.EdEntityDesignator
   robot_smach_states.util.designators.ed_designators.EntityByIdDesignator
   robot_smach_states.util.designators.ed_designators.ReasonedEntityDesignator
   robot_smach_states.util.designators.ed_designators.LockToId


Module Contents
---------------

.. py:data:: __author__
   :value: 'loy'


.. py:class:: EdEntityCollectionDesignator(robot, etype='', center_point=None, radius=float('inf'), uuid='', criteriafuncs=None, etype_designator=None, center_point_designator=None, uuid_designator=None, name=None)

   Bases: :py:obj:`robot_smach_states.util.designators.core.Designator`


   Resolves to a collection of Ed entities

   >>> from robot_skills.mockbot import Mockbot
   >>> with redirect_stdout(None): robot = Mockbot()
   >>> entities = EdEntityCollectionDesignator(robot)
   >>> check_resolve_type(entities, [Entity]) #This is more a test for check_resolve_type to be honest :-/

   Designates a collection of entities of some type, within a radius of some center_point, with some id,
   that match some given criteria functions.
   @param robot the robot to use for Ed queries
   @param etype the type of the entity to resolve to (default: any type)
   @param center_point combined with radius: a sphere to search an entity in
   @param radius combined with center_point: a sphere to search an entity in
   @param uuid the ID of the object to get info about
   @param etype_designator same as type but dynamically resolved trhough a designator. Mutually exclusive with type
   @param center_point_designator same as center_point but dynamically resolved through a designator.
           Mutually exclusive with center_point
   @param uuid_designator same as id but dynamically resolved through a designator. Mutually exclusive with id


   .. py:attribute:: ed


   .. py:attribute:: etype
      :value: ''



   .. py:attribute:: center_point
      :value: None



   .. py:attribute:: radius


   .. py:attribute:: uuid
      :value: ''



   .. py:attribute:: criteriafuncs
      :value: []



   .. py:attribute:: etype_designator
      :value: None



   .. py:attribute:: center_point_designator
      :value: None



   .. py:attribute:: uuid_designator
      :value: None



   .. py:method:: _resolve()


.. py:class:: EdEntityDesignator(robot, etype='', center_point=None, radius=float('inf'), uuid='', criteriafuncs=None, weight_function=None, etype_designator=None, center_point_designator=None, uuid_designator=None, name=None)

   Bases: :py:obj:`robot_smach_states.util.designators.core.Designator`


   Resolves to an entity from an Ed query

   Designates an entity of some type, within a radius of some center_point, with some id,
   that match some given criteria functions.
   @param robot the robot to use for Ed queries
   @param etype the type of the entity to resolve to (default: any type)
   @param center_point combined with radius: a sphere to search an entity in
   @param radius combined with center_point: a sphere to search an entity in
   @param uuid the ID of the object to get info about
   @param criteriafuncs a list of functions that take an entity and return a bool (True if criterium met)
   @param weight_function returns a weight for each entity, the one with the lowest weight will be selected
   (could be a distance calculation)
   @param etype_designator same as type but dynamically resolved trhough a designator. Mutually exclusive with type
   @param center_point_designator same as center_point but dynamically resolved trhough a designator.
   Mutually exclusive with center_point
   @param uuid_designator same as id but dynamically resolved through a designator. Mutually exclusive with id


   .. py:attribute:: robot


   .. py:attribute:: ed


   .. py:attribute:: etype
      :value: ''



   .. py:attribute:: center_point
      :value: None



   .. py:attribute:: radius


   .. py:attribute:: uuid
      :value: ''



   .. py:attribute:: criteriafuncs
      :value: []



   .. py:attribute:: weight_function


   .. py:attribute:: etype_designator
      :value: None



   .. py:attribute:: center_point_designator
      :value: None



   .. py:attribute:: uuid_designator
      :value: None



   .. py:method:: lockable()

      Designators can be lockable. This means their value does not change between calls to .lock and .unlock().
      What this means exactly is different for different subclasses.

      For example, an EdEntityDesignator must lock only the Entity's ID and not the Python object itself.
      In the latter case, ED can update the Entity's info but the designator will not update that because its
      locked to a Python-object.
      For Arms, it makes sense to lock to the actual Python-object with the current implementation.

      For a lot of Designators, .lockable() will yield the Error below, but in those cases it will make sense,
      because locking them has no meaning.
      Then, calling .lock will fail as well. States that want a .lock method should check for it.



   .. py:method:: _resolve()


.. py:class:: EntityByIdDesignator(robot, uuid, name=None)

   Bases: :py:obj:`robot_smach_states.util.designators.core.Designator`


   A Designator defines a goal, which can be defined at runtime or at write-
   time. Its value cannot be set, it can only be get.  This allows to later
   define Designators that take a goal specification, like a query to a world
   model.

   >>> d = Designator("Initial value", name="tester")
   >>> d.resolve()
   'Initial value'

   >>> assert(issubclass(d.resolve_type, str))

   Designate an entity by its ID. Resolves to the entity with that ID

   :param robot: Robot who's worldmodel to use
   :param uuid: ID of the entity. If no such ID, resolves to None
   :param name: Name of the designator for introspection purposes


   .. py:attribute:: ed


   .. py:attribute:: uuid


   .. py:method:: _resolve()


   .. py:method:: __repr__()


.. py:class:: ReasonedEntityDesignator(robot, query, name=None)

   Bases: :py:obj:`robot_smach_states.util.designators.core.Designator`


   A Designator defines a goal, which can be defined at runtime or at write-
   time. Its value cannot be set, it can only be get.  This allows to later
   define Designators that take a goal specification, like a query to a world
   model.

   >>> d = Designator("Initial value", name="tester")
   >>> d.resolve()
   'Initial value'

   >>> assert(issubclass(d.resolve_type, str))

   Designate an entity by its ID. Resolves to the entity with that ID

   :param robot: Robot who's worldmodel and reasoner to use. Robot must have a reasoner
   :param query: query to the reasoner. The first answer is cast to string and used as ID
   :param name: Name of the designator for introspection purposes


   .. py:attribute:: robot


   .. py:attribute:: querystring


   .. py:attribute:: _locker
      :value: None



   .. py:method:: _resolve()


   .. py:method:: lockable()

      Designators can be lockable. This means their value does not change between calls to .lock and .unlock().
      What this means exactly is different for different subclasses.

      For example, an EdEntityDesignator must lock only the Entity's ID and not the Python object itself.
      In the latter case, ED can update the Entity's info but the designator will not update that because its
      locked to a Python-object.
      For Arms, it makes sense to lock to the actual Python-object with the current implementation.

      For a lot of Designators, .lockable() will yield the Error below, but in those cases it will make sense,
      because locking them has no meaning.
      Then, calling .lock will fail as well. States that want a .lock method should check for it.



.. py:class:: LockToId(robot, to_be_locked, name=None)

   Bases: :py:obj:`robot_smach_states.util.designators.core.Designator`


   An Entity...Designator's resolve() method may return a different Entity everytime.
   For some cases, this may be unwanted because a process has to be done with the same Entity for tha action to be
   consistent.
   In that case, a designator resolving to a different object every time is not usable.
   A LockToId will resolve to the same Entity after a call to .lock() and
   will only resolve to a different Entity after an unlock() call.
   This is done by remembering the Entity's ID

   Constructor

   :param robot: robot object
   :param to_be_locked: designator to be locked
   :param name: (optional) might come in handy for debugging


   .. py:attribute:: robot


   .. py:attribute:: to_be_locked


   .. py:attribute:: _locked_to_uuid
      :value: None



   .. py:attribute:: _locked
      :value: False



   .. py:method:: lock()


   .. py:method:: unlock()


   .. py:method:: _resolve()


   .. py:method:: __repr__()


