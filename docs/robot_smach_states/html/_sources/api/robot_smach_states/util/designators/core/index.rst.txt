robot_smach_states.util.designators.core
========================================

.. py:module:: robot_smach_states.util.designators.core


Attributes
----------

.. autoapisummary::

   robot_smach_states.util.designators.core.__author__
   robot_smach_states.util.designators.core.T
   robot_smach_states.util.designators.core.writeable


Classes
-------

.. autoapisummary::

   robot_smach_states.util.designators.core.Designator
   robot_smach_states.util.designators.core.VariableDesignator
   robot_smach_states.util.designators.core.VariableWriter


Module Contents
---------------

.. py:data:: __author__
   :value: 'loy'


.. py:data:: T

.. py:class:: Designator(initial_value=None, resolve_type=None, name=None)

   Bases: :py:obj:`Generic`\ [\ :py:obj:`T`\ ]


   A Designator defines a goal, which can be defined at runtime or at write-
   time. Its value cannot be set, it can only be get.  This allows to later
   define Designators that take a goal specification, like a query to a world
   model.

   >>> d = Designator("Initial value", name="tester")
   >>> d.resolve()
   'Initial value'

   >>> assert(issubclass(d.resolve_type, str))

   Initialization method

   :param initial_value: Initial value, should match the given resolve_type.
                         None is allowed if a resolve_type is provided.
   :param resolve_type: Type to which this designator should resolve.
                        If None, use the type of the initial value. Value
                        must be not None in that case.
   :vartype resolve_type: Type or a list with a single type (the element type).
                          The latter represents list of values where each
                          value has the element type.

   :param name: name used for debugging purposes
   :vartype name: str


   .. py:attribute:: instances


   .. py:attribute:: _name
      :type:  str
      :value: None



   .. py:attribute:: __initial_value
      :value: None



   .. py:method:: resolve()

      Selects a new goal and sets it as the current value.

      Don't override this method, override self._resolve() instead.



   .. py:method:: fail_with_type_error(result_type, resolve_type)


   .. py:method:: _resolve()


   .. py:method:: _get_resolve_type()

      The currently selected goal



   .. py:method:: _get_name()

      The currently selected goal



   .. py:attribute:: resolve_type
      :type:  T


   .. py:attribute:: name
      :type:  str


   .. py:method:: __repr__()


   .. py:method:: lockable()
      :abstractmethod:


      Designators can be lockable. This means their value does not change between calls to .lock and .unlock().
      What this means exactly is different for different subclasses.

      For example, an EdEntityDesignator must lock only the Entity's ID and not the Python object itself.
      In the latter case, ED can update the Entity's info but the designator will not update that because its
      locked to a Python-object.
      For Arms, it makes sense to lock to the actual Python-object with the current implementation.

      For a lot of Designators, .lockable() will yield the Error below, but in those cases it will make sense,
      because locking them has no meaning.
      Then, calling .lock will fail as well. States that want a .lock method should check for it.



   .. py:method:: _get_current()


   .. py:attribute:: current


.. py:class:: VariableDesignator(initial_value=None, resolve_type=None, name=None)

   Bases: :py:obj:`Designator`


   A VariableDesignator simply contains a variable that can be set if you have a writer for it.

   >>> #Create a VariableDesignator with a string
   >>> v = VariableDesignator('Hello')
   >>> v.resolve() #No surprise, it resolves to the given string!
   'Hello'

   You cannot directly set a VariableDesignator though, you must obtain a VariableWriter through the
   .writeable-attribute

   Initialization method

   :param initial_value: Initial value, should match the given resolve_type.
                         None is allowed if a resolve_type is provided.
   :param resolve_type: Type to which this designator should resolve.
                        If None, use the type of the initial value. Value
                        must be not None in that case.
   :vartype resolve_type: Type or a list with a single type (the element type).
                          The latter represents list of values where each
                          value has the element type.

   :param name: name used for debugging purposes
   :vartype name: str


   .. py:attribute:: _current
      :value: None



   .. py:attribute:: writeable


   .. py:method:: _set_current_protected(value)


   .. py:method:: _resolve()


   .. py:method:: _set_current(value)


   .. py:method:: _get_current()


   .. py:attribute:: current


.. py:class:: VariableWriter(variable_designator)

   Bases: :py:obj:`object`


   When writing to a VariableDesignator you must use a writer,
       to make it explicit who changes designators so you can directly spot the changer.
   This way, the dataflow can be more accurately visualized and understood.

   >>> #Create a VariableDesignator with a string
   >>> v = VariableDesignator('Hello')
   >>> v.resolve() #No surprise, it resolves to the given string!
   'Hello'
   >>> #Writing to the designator directly will fail.
   >>> v.current = 'World'   # doctest: +IGNORE_EXCEPTION_DETAIL
   Traceback (most recent call last):
     ...
   DeprecationWarning: ...

   >>> v.resolve() #Still unchanged
   'Hello'
   >>> #Instead, use a writer to assign to a VariableDesignator
   >>> w = writeable(v)
   >>> w.write('World')
   >>> v.resolve() #Now it works!
   'World'

   >>> v2 = VariableDesignator(['a', 'b', 'c'], resolve_type=[str])
   >>> v2.resolve()
   ['a', 'b', 'c']
   >>> v2w = v2.writeable
   >>> v2w.write(v2.resolve() + ['d'])
   >>> v2.resolve()
   ['a', 'b', 'c', 'd']

   >>> v2w.write('a')  # doctest: +ELLIPSIS
   Traceback (most recent call last):
       ...
   TypeError: Cannot assign a <class 'str'> to Designator(...) which has a list resolve_type: ...
   >>> v2w.write(None)  # doctest: +ELLIPSIS
   Traceback (most recent call last):
       ...
   TypeError: Cannot assign a <class 'NoneType'> to Designator(...) which has a list resolve_type: ...


   .. py:attribute:: instances


   .. py:attribute:: variable_designator


   .. py:attribute:: name


   .. py:method:: write(value)

      Write a value to the designator this writer is associated with.

      :param value: the value to be written
      :return: None

      Value can be either a singular object or a list, which may be empty or not.
      The singular object's type has to fit the resolve_type.
      If the value is a list, then resolve_type must also be a list,
          which the only element being the type each value-element must have.
      In case the value-list has an element,
          this element must be of the type specified by the only element in the resolve_type-list
      In case the value-list is empty, we simply assign that empty list without any type checking.



   .. py:method:: _set_current(value)


   .. py:attribute:: current


   .. py:method:: _get_resolve_type()


   .. py:attribute:: resolve_type


   .. py:method:: resolve(*args, **kwargs)


   .. py:method:: __repr__()


.. py:data:: writeable

